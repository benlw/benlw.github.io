<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Effective sampling in SE(3)</title>
    <url>/posts/e9246c12/</url>
    <content><![CDATA[<h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><ul>
<li>对于基于采样的刚体路径规划问题,具体的,包括如何在$\rm SE(3)$定义合适的距离,采样函数,以及采样点插值.</li>
</ul>
<p>参考 Effective sampling and distance metrics for rigid body path planning</p>
<p><img src="sampling_sphere.png" alt=""></p>
<h5 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h5><ol>
<li>methods for generating a uniform distribution of randomly sampled rotations for both euler angle and quaternion parameterizations</li>
<li>distance metics on $\rm SE(3)$ and geodesic interpolation function for rotations.</li>
<li>experimental result</li>
</ol>
<p>刚体位形空间通常定义为所有可能位置和定向的半直积.任何刚体运动都可以通过绕某轴的旋转加上移动来实现.刚体运动曲线在$\rm SE(3)$上.</p>
<p>可以证明,there are no differentiable bi-invariant distance metrics on $\rm SE(3)$[7].</p>
<h6 id="旋转矩阵的表示"><a href="#旋转矩阵的表示" class="headerlink" title="旋转矩阵的表示"></a>旋转矩阵的表示</h6><ul>
<li>Rotation Matrices</li>
</ul>
<p>不容易定义 $\rho(R_1,R_2)$旋转矩阵间距离及插值以产生一系列光滑中间点.</p>
<ul>
<li>Euler angles</li>
</ul>
<p>多对一</p>
<ul>
<li>四元数 (excellent choice)</li>
</ul>
<p>任意定向可以由axis $v= (v_x,v_y,v_z)$及旋转角$\theta$得到,对应单位四元数$|Q|=1$</p>
<p>$$ Q = (\omega,x,y,z) = (\cos(\frac{\theta}{2}),v_x\sin(\frac{\theta}{2}),v_y\sin(\frac{\theta}{2}),v_z\sin(\frac{\theta}{2}) )$$</p>
<p>Translation component可以直接处理: $(x,y,z) = rand()$</p>
<p>对于旋转,直观的,可以选取随机的旋转轴以及旋转角. Arvo’s Method[17]</p>
<p>伪代码:<br>(生成均匀分布的四元数)<br>$s = rand()$<br>$\sigma_1 = \sqrt{1-s}, \sigma_2 = \sqrt{s}$;</p>
<p>$\theta_1 =2\pi<em>rand(), \theta_2=2\pi</em>rand()$</p>
<p>return$(w=\cos(\theta_2)<em>\sigma_2, x=\sin(\theta_1)</em>\sigma_1, y =\cos(\theta_1)<em>\sigma_1, z=\sin(\theta_2)</em>\sigma_2)$</p>
<h6 id="“距离函数”"><a href="#“距离函数”" class="headerlink" title="“距离函数”"></a>“距离函数”</h6><p>直观的,定义$q =(R,p)$,则 $\rho = w_p|| p_o-p_1||+ w_Rf(R_0.R_1)$</p>
<p>恰当的权重见[4,5]</p>
<ul>
<li>四元数</li>
</ul>
<p>Park与Ravani对$\rm SO(3)$定义双不变距离测度$f = ||log(Q_1^{-1}Q_2)||$</p>
<p>另一种选择,内积,$\lambda =Q_1\cdot Q_2 = w_1w_2+ x_1x_2+..$,, 值得注意的是,$Q$与$-Q$表示相同rotation. $\rho = w_R*(1-||\lambda||)$</p>
<h6 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h6><p>简单选择algorithm7做线性插值,$f\in[0,1]$</p>
<hr>
]]></content>
      <categories>
        <category>sampling</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>读论文path planning and collision avoidance for robots并仿真</title>
    <url>/posts/c7ca1a9b/</url>
    <content><![CDATA[<h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><ul>
<li>通读论文并实现论文的例子</li>
</ul>
<p><img src="scene.png" alt=""></p>
<ul>
<li>搭建一个基本的框架(包含问题描述,障碍物避障准则(代数层面),离散,B-spline,SQP等部分),将其仿真实现,并可应用于n-dof的机械臂.</li>
</ul>
<p>仿真如下:</p>
<p>论文$t_f$最优时间为0.4261s, Matlab返回(局部?)最优解为0.4412</p>
<p><img src="testAnimated.gif" alt=""></p>
<p><font color=red>这篇文章对于最优控制的框架[^1]值得学习,尤其利用代数将避障处理成不等式约束,再利用隐面剔除策略减少约束.本文在前面newton-euler dynamics算法的基础上,结合B样条将问题离散,简单(在未引入隐面剔除策略下,调用<code>fmincon</code>函数)实现论文的optimal time数值算例.</font></p>
<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h5><ol>
<li>动力学方程</li>
</ol>
<p>可参考上一篇博文,这部分算法已经在Vrep中验证过了.简单验证一下是否和论文的一样 p462 </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% grav = inversedyn(robot.thetalist, zeros(3, 1), zeros(3, 1) ,robot.g, robot.T, robot.InertiaMtr, robot.Twist)</span></span><br><span class="line"><span class="comment">% k = -9.81;</span></span><br><span class="line"><span class="comment">% F_q_u = [0; -k*l*cos(robot.thetalist(2))*(0.5*m2+m3+m4)-k*l*cos(robot.thetalist(2)+robot.thetalist(3))*(0.5*m3+m4);...</span></span><br><span class="line"><span class="comment">%             -k*l*cos(robot.thetalist(2)+robot.thetalist(3))*(0.5*m3+m4)]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 核对无误 但是输入文章fig9的u1,u2,u3输入进去,杆1不怎么移动,这里应该是论文fig9有问题,我们将其乘以scaling factor 100. aha,作者回复我了,说忘记在论文提fig9是经过normalized,实际边界在-100~100Nm.此外,作者建议不要考虑重力(insufficient control 将导致robot崩溃 - -),关于初值的选取作者建议除了论文中的scaling方法,还可以从无障碍物开始训练,以constructing good initial guess.本博文也将采用这一策略.</p>
</blockquote>
<ol start="3">
<li>避障准则</li>
<li>B-spline 直接离散化</li>
<li>SQP</li>
<li>隐面剔除策略</li>
</ol>
<h5 id="序列二次规划-SQP"><a href="#序列二次规划-SQP" class="headerlink" title="序列二次规划(SQP)"></a>序列二次规划(SQP)</h5><p>因为时间有限,本此仿真将利用Matlab优化函数处理离散最优问题.先对<code>fmincon</code>有个大概了解.后续腾出手来再补充SQP.</p>
<p>作为Nonlinear programming solver,求解如下形式:<br>$$ min_x f(x) ~ s.t : c(x)\leq 0, ceq(x) = 0, A\cdot x \leq b, Aeq\cdot x = beq, and, lb \leq x \leq ub  $$</p>
<h5 id="开发进度"><a href="#开发进度" class="headerlink" title="开发进度"></a>开发进度</h5><ul>
<li><p>spline_curve(torque_grid_point, t, order, knot_vector),样条离散,输入 $t \in [0,1]$ 计算torque. 关于初值的选取我问了论文作者,他说如果没记错的话,对于torque control取了21个控制点(de boor point), 一阶样条,与auxiliary control $\omega$一致.</p>
</li>
<li><p>边界约束</p>
</li>
</ul>
<p>$$u(t)\in U: = {u\in \mathbb{R}^m | u_{min} \leq u \leq u_{max} }$$</p>
<p>$$ \omega_{i,k} \geq 0, for~ i = 1,…,12, k = 1,…,21 $$ </p>
<p>(为和论文保持统一,只考虑load和obstacle,每个cuboid六个面, 共12次, 时间节点划分为21个.)</p>
<ul>
<li>关于线性等式约束和线性不等式约束.</li>
</ul>
<p>无. </p>
<ul>
<li>关于非线性等式约束和非线性不等式约束.</li>
</ul>
<p>粗略一看,边界约束属于线性等式约束,在这个离散最优问题上,我们对动力学方程离散有两种方式: 1.由各时间节点 joint angle进行样条离散,2.是按论文的,对control进行离散.</p>
<p>从动力学方程的角度,似乎不太好按第一种方式进行离散,因为时间最优控制一般是bang-bang控制,关节轨迹一般需要比较高阶的样条(但在initial_guess时会更直观一点吧?).不过结果应该差不多吧,按这种方式离散, 上述边界约束则是非线性约束.</p>
<p>我还是按论文走.对control离散之后,调用正动力学计算$\ddot{\theta}$,选择合适的积分策略(这里简单选择euler显示格式,因为步长划分比较多).再调用正运动学计算负载位姿$T_{load} = [R,p;0 0 0 1] $,得到离散后避障约束方程(P444,OCP Problem)以及关节边界约束:</p>
<p>$$   G_I(x_k(z))^T w_I,h(t_k) =  0, I = 1,…,M=12,~~ K = 0,…,N $$<br>$$   g_I(x_k(z))^T w_I,h(t_k) &lt;= -e $$<br>$$   \phi(x_o,x_N(z)) = 0; $$</p>
<p>在程序中我设置了两个模式,以便切换.</p>
<blockquote>
<p><code>robot.collision_mode = 0; %false = 0 默认不考虑</code>, 进行最省时间路径规划</p>
</blockquote>
<blockquote>
<p>Q1.错误使用 barrier<br>Nonlinear constraint function is undefined at initial point. Fmincon cannot continue.</p>
</blockquote>
<p>遇到这个问题需要检查一下,调用<code>nonlinear_constraint(initial_guess)</code> 看是不是有NaN.(问题主要出在计算正动力学时 $ M $ 矩阵奇异.这与我们初值选取有关,如果想要避免这一问题,初始值可以稍微小一点.)</p>
<blockquote>
<p>Q2.Local minimum found that satisfies the constraints. 弄了个乌龙,返回满足局部最优,于是将其绘制轨迹曲线,发现都为0, 才发现最优化问题改变了x(1:6,1)这几个值,边界条件得管好呀..</p>
</blockquote>
<!--未经过任何优化,运行1min左右,得到了一个(忽略障碍)局部(非bang-bang,应该还有继续优化空间)最优时间解.<font color=red>如下</font>

![](release_1_without_obstacles.png) -->

<p> 有了这么个解之后,可以做很多事情了.</p>
<blockquote>
<p>关于为什么将$[0,tf]$转化到$[0,1]$</p>
</blockquote>
<p>如果我没理解错的话,除了为了分析Hessian之外,在编程中我发现,如果tf过大,划分步长不够的话,<code>forwardynamics</code>函数容易积累误差.想必这也是论文作者敢划分21点的原因,平均下来步长也就0.05,perfect!</p>
<ul>
<li>局部最优与全局<blockquote>
<p>探讨一下全局的策略.待完善. 涉及SQP一些技术手段,待后面再讨论. 本文仅在运行程序时做一些小记录.</p>
</blockquote>
</li>
</ul>
<p>在训练initial guess的时候, 训练到了<code>iter = 10</code>,从下午六点到晚上八点半才训练出一个较好的初值.这次优化包括了<code>6+ 3*21 + 12*21 + 1</code>个变量,其实应该像论文中所采取的做法,将Hessian输入到sqp求解中,能有效提高计算效率.经过我的测试,一个good initial guess可以将计算缩短,我在目标函数中加入了惩罚项 $\alpha||norm(\omega_i)||$,可以稍微提高鲁棒性.</p>
<p><font color=red>对大于20维优化问题,不建议用Matlab <code>fmincon</code>,本笔记只做一个简单的测试.具体实践中,还应该吃透一些常用的优化算法,编写好优化问题的梯度与Hessian.</font></p>
<ul>
<li>exitflag</li>
</ul>
<p>-2: No feasible point<br>-1: The output function terminated the algorithm<br> 0: Iterations exceeded options.<br> 1: 某种情况达到了收敛. 具体见doc fmincon.</p>
<ul>
<li>数值结果</li>
</ul>
<p>与论文控制力有些差别,计算差异体现在积分策略,以及 $\omega$ 的边界条件上.</p>
<p>注: 经测试,选择相同fmincon的优化算法,matlab 2019b与2015b均可以跑到相同结果.</p>
<p><img src="Res.png" alt=""><br><img src="omega.png" alt=""><br><img src="res.png" alt=""></p>
<ul>
<li>关于梯度与Hessian阵.</li>
</ul>
<p>这是一个可以对论文改进的方向.博文到这里, 耗费一周时间总算完成了一个OCP问题小实验.</p>
<hr>
<h5 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h5><ul>
<li><input disabled="" type="checkbox"> <p>因为论文采用的是一阶样条, 为了精简计算, 可以使用表达式避免调用<br>$$ u = u_i + \frac{(t- t_i)}{t_{i+1}-t_i}(u_{i+1}-u_i) , t \in [t_i-t_{i+1}] $$</p>
</li>
<li><input disabled="" type="checkbox"> <p>编写程序贪快,可以将一些参数变量放到<code>main</code>函数.</p>
</li>
<li><input disabled="" type="checkbox"> <p>隐面剔除</p>
</li>
<li><input disabled="" type="checkbox"> <p>Hessian矩阵</p>
</li>
<li><input disabled="" type="checkbox"> <p><a href="https://ww2.mathworks.cn/products/parallel-computing.html" target="_blank" rel="noopener">Parallel Computing Toolbox - MATLAB</a> 并行计算</p>
</li>
</ul>
<hr>
<p>参考文献</p>
<p>[^1]: path planning and collision avoidance for robots.</p>
]]></content>
      <categories>
        <category>optimal control</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>仿真</tag>
      </tags>
  </entry>
  <entry>
    <title>coordinate-invariant dynamics algorithm验证</title>
    <url>/posts/1e752288/</url>
    <content><![CDATA[<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul>
<li>以平面RRR三连杆和空间三连杆为例,通过选择两种标架(joint frame以及center of mass frame),实现坐标不变算法对机械臂正逆动力学仿真:包括对inertial matrix, energy的分析; </li>
<li>搭建一个基本的creatrobot函数(其中各link为cuboid),采用euler数值积分,将仿真可视化,并与商业软件V-rep对比(对比末端轨迹),在此基础上测试变分积分子.</li>
</ul>
<h4 id="Coordinate-invariant-algorithm"><a href="#Coordinate-invariant-algorithm" class="headerlink" title="Coordinate-invariant algorithm"></a>Coordinate-invariant algorithm</h4><p>criag的书采用的就是这一方法,李泽湘的新的lecture也加入了这部分内容,坐标系建立在关节处,这一点与Park不同.</p>
<p>起初研究这部分内容,我还产生了一个疑问,为了保证惯性矩阵Inertia Matrix的简洁优雅,所以计算是在center of mass这一标架上进行的,$\tau = F^T_iS_i$, 其中$S_i$为screw aixs of i joint expressed in {i} frame.那么$\tau$结果应该是施加在第i杆质心上的?</p>
<p>先说结果,从程序实验来看,其实两种方法实验结果一致(包括得到的力矩).</p>
<p>我还没有仔细证明,但思路应该是要利用质心Inertia Matrix是$I_b$,那么在关节处(frame {s})应为为$Ad^T_gI_b Ad_g$. </p>
<!--
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Is</span> = <span class="title">inertialmatirx_check</span><span class="params">(T,Ib)</span></span></span><br><span class="line"><span class="comment">%测试 I_s = Ad^T_T(bs)I_bAd_T&#123;bs&#125; 将cm惯性矩阵转换到joint处</span></span><br><span class="line"><span class="comment">%&#123;</span></span><br><span class="line"><span class="comment">Mb = diag([172.27656, 172.27656, 172.27656, 3.16441, 32.90891, 34.31683]);</span></span><br><span class="line"><span class="comment">Rbs = [0.98655, 0.16044, 0.03136; 0.0005, 0.18889, -0.982; -0.16347, 0.9688, 0.18627];</span></span><br><span class="line"><span class="comment">Pbs = [0.74197; 0.019914; -0.013597];%Pbs = [0;0;0];%</span></span><br><span class="line"><span class="comment">Tbs = [Rbs, Pbs; 0 0 0 1];</span></span><br><span class="line"><span class="comment">Is = inertialmatirx_check(Tbs,Mb);</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line">Is =  Adjoint(T)'*Ib*Adjoint(T);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!-- <s>这里得到的Inertial Matrix不是[I_c ,0 ; 0 ,m]形的,目前我没找到相关的文献描述,但从推导来看,是没有问题的(加上惯性矩阵的转换,应该可以推导出下面两种方式等价).如果将对角置0,下述程序得不到相同的结果.</s> 纠正: 广义惯性矩阵 -->

<h5 id="center-of-mass"><a href="#center-of-mass" class="headerlink" title="center of mass"></a>center of mass</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%主要参数</span></span><br><span class="line"><span class="comment">%center of mass 相对位置</span></span><br><span class="line">M01 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.05</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M12 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.10</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M23 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.10</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M34 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.05</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">G = <span class="built_in">diag</span>(<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">6</span>)); <span class="comment">%inertia matrix</span></span><br><span class="line">w1 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">1</span>]; q1 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>]; q2 = [<span class="number">0.10</span>;<span class="number">0</span>;<span class="number">0</span>]; q3 = [<span class="number">0.20</span>;<span class="number">0</span>;<span class="number">0</span>];</span><br><span class="line">S = [[<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q1)], ...</span><br><span class="line">     [<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q2)], ...</span><br><span class="line">     [<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q3)]];</span><br></pre></td></tr></table></figure>

<!--  <s>我最初假设过长方体密度是1kg/m^3,但是惯性矩阵在matlab数量级在1e-5,太小了,导致结果与v-rep不一致,大概率是matlab舍入误差造成了,这一点可以加上format long试一下,记录完才想起来,就先留个位以后填吧.</s>

我又用single rb测试了一下(毕竟单个刚体的更简单,可以直接写出方程),应该是Vrep软件舍入误差问题,我已经去论坛反馈了.- - 等回头再看看.  

https://forum.coppeliarobotics.com/viewtopic.php?f=9&t=8356&p=32424#p32424 提完问我去逛了下手册,发现vrep里的 inertial matrix has divided by the mass. 所以是我MATLAB程序在计算cuboid惯性矩阵时除了问题,忘记给$I$部分乘上m了. 乌龙...
-->

<blockquote>
<p>当inertia 矩阵非常小时, 欧拉积分不太合适,容易积累误差.</p>
</blockquote>
<h5 id="joint-frame"><a href="#joint-frame" class="headerlink" title="joint frame"></a>joint frame</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%主要参数</span></span><br><span class="line"><span class="comment">%center of mass 相对位置</span></span><br><span class="line">M01 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.00</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M12 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.10</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M23 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.10</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M34 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.10</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">G = <span class="built_in">diag</span>(<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">6</span>)); <span class="comment">%inertia matrix</span></span><br><span class="line">T = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">-0.05</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">Ic = inertialmatirx_check(T,G) <span class="comment">%转化为Ic标架下</span></span><br><span class="line">w1 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">1</span>]; q1 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>]; q2 = [<span class="number">0.10</span>;<span class="number">0</span>;<span class="number">0</span>]; q3 = [<span class="number">0.20</span>;<span class="number">0</span>;<span class="number">0</span>];</span><br><span class="line">S = [[<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q1)], ...</span><br><span class="line">     [<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q2)], ...</span><br><span class="line">     [<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q3)]];</span><br></pre></td></tr></table></figure>

<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><ul>
<li><p>Matlab<br><img src="testAnimated.gif" alt=""></p>
</li>
<li><p>V-rep<br><img src="vrep.gif" alt=""></p>
</li>
<li><p>对比.在Matlab中,步长取了50ms,与Vrep中一致,在仿真软件中选了最新的物理引擎.<br><img src="file.jpg" alt=""></p>
</li>
</ul>
<h5 id="下一步将继续研究离散的算法-待续"><a href="#下一步将继续研究离散的算法-待续" class="headerlink" title="下一步将继续研究离散的算法.(待续)"></a>下一步将继续研究离散的算法.(待续)</h5><hr>
<h4 id="附-V-rep基础教程"><a href="#附-V-rep基础教程" class="headerlink" title="附:V-rep基础教程"></a>附:V-rep基础教程</h4><p> 推荐阅读顺序如下:</p>
<ul>
<li><a href="https://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm" target="_blank" rel="noopener">Building a clean model tutorial</a> 从导入模型,建立关节开始大致熟悉一下流程,然后再用问题驱动,阅读User Manual最佳.</li>
<li><a href="https://www.coppeliarobotics.com/helpFiles/" target="_blank" rel="noopener">CoppeliaSim User Manual</a></li>
<li>最后,在Youtube有不少优秀的视频,例如<a href="https://www.youtube.com/watch?v=jfUA2W-niIc" target="_blank" rel="noopener">从CAD软件中导出Vrep读取的urdf文件并通过child Script控制</a><blockquote>
<p>这款仿真软件号称是机器人方面的瑞士军刀,在验证开发的算法以及可视化上很给力,并且可以通过API与Matlab通信,目前我只关注到这一层面,算法的研究上我还是用Matlab矩阵运算多一些,慢慢的结合V-rep做一些核对工作(<s>有时间有必要了解下它内部物理引擎所采取的算法,也先留个位吧</s>-.-)</p>
</blockquote>
</li>
</ul>
<h5 id="Bullet"><a href="#Bullet" class="headerlink" title="Bullet"></a>Bullet</h5><p>Bullet Physics is a professional <b>open source collision detection, rigid body and soft body dynamics<br>library</b>. The library is free for commercial use under the ZLib license. 在碰撞检测中用了GJK算法,室友以前还研究过,haha..巧的是,对于逆动力学算法,这个库采用的也是 Recursive Newton-Euler Algorithm (RNEA),而且<a href="https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=12437" target="_blank" rel="noopener">The computation of the joint space inertia (mass) matrix  is using the Composite Rigid Body Algorithm</a>.与我在上述实验中采用的算法一样,因为是开源的(它的积分策略为Symplectic Euler integrator),我们有必要也关注下它的<a href="https://github.com/erwincoumans/bullet3/tree/master/src/BulletInverseDynamics" target="_blank" rel="noopener">Github 仓库</a>.<!--MultiBodyTree::MultiBodyImpl::calculateMassMatrix --></p>
<ul>
<li><a href="http://www.cs.kent.edu/~ruttan/GameEngines/lectures/Bullet_User_Manual" target="_blank" rel="noopener">user_Manual</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>动力学</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>Matlab &amp; Vrep</tag>
      </tags>
  </entry>
  <entry>
    <title>读论文real time obstacle avoidance for manipulators and moile robots并仿真</title>
    <url>/posts/81ffa1cf/</url>
    <content><![CDATA[<h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><ul>
<li>精读论文并简单实现论文的例子</li>
<li>搭建一个基本的框架(包含正运动学,jacobian,正逆动力学部分),将其仿真实现,并可应用于n-dof的机械臂.</li>
</ul>
<p>仿真如下:(t=0.01,红色圆表示安全距离,蓝色圆为障碍.*点为目标点)<br><img src="artificial_potential.gif" alt=""></p>
<p>解决规划问题的论文有不少,但最经典的应该还是khatib1986那篇文章:real time obstacle avoidance for manipulators and moile robots.总的说来就是在operation space计算控制律,并通过jacobian矩阵将其转化为力矩,求得joint space的控制力作为控制信号.有陷入局部极小点的问题(这一块我将放在mathematica中进行分析,这款软件可视化很给力,尽管我还是个初学者)</p>
<h5 id="大体思路如下"><a href="#大体思路如下" class="headerlink" title="大体思路如下:"></a>大体思路如下:</h5><ol>
<li>寻找each arm segment距离障碍最近点,如果满足一定条件,则施加斥力</li>
<li>将斥力转化为关节力矩</li>
<li>作为控制律</li>
</ol>
<p>我们希望整个机械臂避免碰撞,但目前我们将问题减少至仅关心每段到障碍物最近的点.如果达到距离阀值则将施加斥力使其远离障碍.</p>
<p>为了找到手臂距离障碍物最近点$p_{psp}$,假设$x_c(:,i)$和$x_c(:,i+1)$为手臂(考虑直线)首尾端点.$ob_{orgin}$为障碍物中心.</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 计算各杆距离障碍物最近点closest,dist到障碍物中心距离,drhodx最近点指向障碍物外点向量</span></span><br><span class="line">taurep = <span class="built_in">zeros</span>(n,<span class="number">1</span>); <span class="comment">%斥力产生的力矩</span></span><br><span class="line">closest = []; dist = []; drhodx = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: n</span><br><span class="line">    vec_line = xc(:,<span class="built_in">i</span>+<span class="number">1</span>) - xc(:,<span class="built_in">i</span>);<span class="comment">%每一节端点</span></span><br><span class="line">    vec_ob_line = ob_orgin - xc(:,<span class="built_in">i</span>); <span class="comment">%the vector from the obstacle to the first line point</span></span><br><span class="line">    projection = <span class="built_in">dot</span>(vec_line,vec_ob_line)/<span class="built_in">dot</span>(vec_line,vec_line);</span><br><span class="line"><span class="keyword">if</span> projection  &lt; <span class="number">0</span></span><br><span class="line">    pclosest = xc(:,<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">elseif</span> projection &gt; <span class="number">1</span></span><br><span class="line">    pclosest = xc(:,<span class="built_in">i</span>+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    pclosest = xc(:,<span class="built_in">i</span>) + projection*vec_line;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">closest = [closest,pclosest]; <span class="comment">%ok</span></span><br></pre></td></tr></table></figure>
<p>利用夹角公式即可.<br>论文中<br>距离函数设计如下(arm closer,response stronger): </p>
<blockquote>
<p>$$F_{psp}=\eta(\frac{1}{\rho}-\frac{1}{\rho_0})\frac{1}{\rho^2}\frac{\partial \rho}{\partial x}$$<br>其中$\rho$表示到障碍的距离,$\rho_0$为安全(threshold)距离.(这里有个问题:如何合适的确定距离阀值呢?-这需要从论文的证明角度进行考虑.) </p>
</blockquote>
<hr>
<p>关键在于第二部分,我采用的是机械臂的几何雅克比矩阵[1] (spatial velocity twist jacobian,为方便表述记为$J_s$),故与论文中的$^0J$相差一个变换.</p>
<blockquote>
<p>几本教材的说法不太统一.</p>
</blockquote>
<p>为了计算受势场力点的jacobian矩阵,有三种方法,以三连杆为例. </p>
<p>第一种见:<a href="http://campus.unibo.it/218782/19/FIR_04_Kinem.pdf" target="_blank" rel="noopener">常见</a></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 方法1 求得world frame EE velocity jacobian</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: n</span><br><span class="line">    omg = p(:,n+<span class="number">1</span>)-p(:,<span class="built_in">i</span>);</span><br><span class="line">    matrix = [<span class="number">0</span>, -omg(<span class="number">3</span>), omg(<span class="number">2</span>); omg(<span class="number">3</span>), <span class="number">0</span>, -omg(<span class="number">1</span>); -omg(<span class="number">2</span>), omg(<span class="number">1</span>), <span class="number">0</span>];</span><br><span class="line">    js(<span class="number">4</span>:<span class="number">6</span>,<span class="built_in">i</span>) = -matrix*Slist(<span class="number">1</span>:<span class="number">3</span>,<span class="built_in">i</span>);</span><br><span class="line">    js(<span class="number">1</span>:<span class="number">3</span>,<span class="built_in">i</span>) = Slist(<span class="number">1</span>:<span class="number">3</span>,<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>第二种为数值计算:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%M为相对位姿&#123;psp&#125; in frame&#123;0&#125;</span><br><span class="line">epsilon &#x3D; 1e-3; </span><br><span class="line">epsilon_inv &#x3D; 1&#x2F;epsilon;</span><br><span class="line">n &#x3D; length(thetalist); % Dimension of the input x;</span><br><span class="line">ee &#x3D; fk(Slist,thetalist);</span><br><span class="line">f0 &#x3D; ee(1:3,4); </span><br><span class="line">% Do perturbation</span><br><span class="line">for i &#x3D; 1 : n</span><br><span class="line">    thetalist_ &#x3D; thetalist;</span><br><span class="line">    thetalist_(i) &#x3D;  thetalist(i) + epsilon;</span><br><span class="line">    ee_ &#x3D; fk(Slist,thetalist_);</span><br><span class="line">    jac(:, i) &#x3D; (ee_(1:3,4) - f0) .* epsilon_inv;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>第三种为[1] 书中所介绍的,利用伴随映射和Twist计算.不再赘述.</p>
<blockquote>
<p>再利用$\tau = J^TM_{x}F_{psp}$计算关节空间的力矩,方便起见,仿真程序设$M_{x}$为单位矩阵.($M$ works to linearize the control)</p>
</blockquote>
<hr>
<p>特别注意的是,虚拟引力的设计,为了使得追踪过程end-effector走直线(不受虚拟斥力时),考虑速度限制,详细见论文.</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">dx = js*dthetalist; </span><br><span class="line">lamb = kp/kv; vmax = <span class="number">2.5</span>; <span class="comment">%x_tilde = xc(:,end)-xd;</span></span><br><span class="line">dxd = lamb*(xd - xc(:,<span class="keyword">end</span>));v = vmax/(<span class="built_in">sqrt</span>(dxd'*dxd));</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">1</span></span><br><span class="line">    v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f_att = [<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);-kv*(dx(<span class="number">4</span>:<span class="number">6</span>,<span class="number">1</span>)-v*dxd)];</span><br></pre></td></tr></table></figure>

<p>关于动力学,采用递推公式(相比Lagrange方法,更适合多自由度情况),我将放在另一篇博客介绍.<a href="https://5imcs.com/posts/1e752288/">链接</a></p>
<p>[1]: A Mathematical Introduction to Robotic Manipulation</p>
]]></content>
      <categories>
        <category>trajectory planning</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>仿真</tag>
      </tags>
  </entry>
  <entry>
    <title>基于POE公式的机械臂正逆运动学仿真(Mathematica篇)</title>
    <url>/posts/f7cdd882/</url>
    <content><![CDATA[<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul>
<li>记录cad的一些基本操作,并且结合Mathematica进行仿真环境搭建.具体包括</li>
</ul>
<ol>
<li>装配机械臂</li>
<li>在仿真环境中导入机械臂三维模型,并且进行正逆运动学仿真.</li>
<li>分析经典数值算法计算效率,并思考一些可改进的方向.</li>
</ol>
<h4 id="移动蛇臂建模"><a href="#移动蛇臂建模" class="headerlink" title="移动蛇臂建模"></a>移动蛇臂建模</h4><h5 id="smiley-由FreeCAD进行零件装配并建立正逆运动学模型-2020年2-1-2-5日"><a href="#smiley-由FreeCAD进行零件装配并建立正逆运动学模型-2020年2-1-2-5日" class="headerlink" title=":smiley:由FreeCAD进行零件装配并建立正逆运动学模型(2020年2.1-2.5日)"></a>:smiley:由FreeCAD进行零件装配并建立正逆运动学模型(2020年2.1-2.5日)</h5><ul>
<li>考虑joint limit(仅考虑了Joint space-&gt;configuration space)</li>
</ul>
<p>仿真结果如下:</p>
<p><img src="exampleRobot_frame.gif" alt=""></p>
<p>相关参考文献:</p>
<ul>
<li><p>1.1995.a weighted least-norm solution based scheme for avoiding joint limits for redundant joint manipulators.IEEE trans on robotics and automation.</p>
</li>
<li><p>2.2018.[文件](A Weighted Gradient Projection Method for Inverse Kinematics of Redundant Manipulators Considering Multiple Performance Criteria.pdf) . </p>
</li>
</ul>
<blockquote>
<p>思路为对 $\dot{q}=J^{-1}\dot{x}$中 $J$ 施加权重. 缺点:WLN或WGP方法在某些情况下无解.</p>
</blockquote>
<h5 id="可改进的地方"><a href="#可改进的地方" class="headerlink" title="可改进的地方:"></a>可改进的地方:</h5><ul>
<li>从反应规划(避障)角度考虑joint limit问题</li>
<li>从连续的角度近似超冗余,提高计算效率</li>
</ul>
<blockquote>
<p>后续将整理freecad的基本操作,以及相关公式和mma代码.  仿真的想法来源于robinvista的<a href="https://blog.csdn.net/robinvista/article/details/70231205" target="_blank" rel="noopener" title="基于Mathematica的机器人仿真环境（机械臂篇）">博客文章</a></p>
</blockquote>
]]></content>
      <categories>
        <category>正逆运动学</category>
      </categories>
      <tags>
        <tag>Mathematica</tag>
        <tag>仿真</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu16.04 软件安装</title>
    <url>/posts/a287a6a9/</url>
    <content><![CDATA[<h4 id="Guake、git、shadowsocks、haroopad以及打印机、SSH"><a href="#Guake、git、shadowsocks、haroopad以及打印机、SSH" class="headerlink" title="Guake、git、shadowsocks、haroopad以及打印机、SSH"></a>Guake、git、shadowsocks、haroopad以及打印机、SSH</h4><a id="more"></a>
<p><s>1. shadowsocks</p>
<p>因为自己搭建了ss的缘故，为了下载各种包方便，我先给自己安装shadowsocks</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang&#x2F;ss-qt5</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure>
<p>安装完毕可以在dash中搜索并打开，输入ShadowSocks服务器的信息即可. 连上之后,我们还不能⻢上上网,还要设置 Ubuntu 的网络代理。点击系统设置,选择网络,接着选择网络代理,然后<code>设置手动(Manual), Socks Host:127.0.0.1 port:1080.</code></p>
<p>在百度中搜索ip，发现在us，说明这个ss设置的是==全局代理==，pac代理懒得设置了. </p>
<p>参考一下@[Ubuntu 16.04 使用 ShadowSocks + Privoxy 科学上网](Ubuntu 16.04 使用 ShadowSocks + Privoxy 科学上网) </s></p>
<blockquote>
<p>现在已改为用v2ray,通过<code>service v2ray start</code>启动</p>
</blockquote>
<ol start="2">
<li>Guake<br>这款终端太赞了，可以半透明，占用内存小，按照&lt;完美应用ubuntu第三版&gt;来配置就可以了(设置开机启动). 此外也可以按照书中的指导配置<code>git</code>，并且push 本地仓库到github. 另外一个有意思的操作就是<a href="http://blog.csdn.net/lmj623565791/article/details/51319147" target="_blank" rel="noopener" title="如何利用github打造博客专属域名">如何利用github打造博客专属域名</a>,有兴趣可以看看. </li>
</ol>
<p><s>3. haroopad<br><code>Haroopad</code>我下载的是<code>haroopad-v0.13.1-x64.tar.gz</code>，挺好用，解压完运行，点击文件-偏好设置可以设置<code>math公式</code>和主题.</s></p>
<blockquote>
<p>改为用boostnote,记笔记更方便 `sudo apt-get install boostnote’</p>
</blockquote>
<ol start="4">
<li>打印机<br>我的打印机是hp2132的，没有官方的linux驱动，所以我在google上找到了一个linux版本的第三方驱动<code>hplip-3.17.10.run</code>，这个驱动已经安装基本支持大部分打印机了，很给力.</li>
</ol>
<p>参考<code>HP Developer Portal _ Installer Walkthrough.pdf</code>，安装的时候出现了一个问题就是无法解决软件依赖，所以我设置了ubuntu<code>软件源为主服务器</code>，并且enable了互联网下载<code>universe和multiuniverse</code>，<strong>关闭了google/stable</strong>.</p>
<ol start="5">
<li>SSH<br>因为经常需要维护自己的梯子，所以在ubuntu上也<code>sudo apt-get install openssh-client</code>安装一个ssh client,用来登录ssh server</li>
</ol>
<p>参考<code>man ssh</code>，通过shell命令<code>ssh root@104.224.162.206 -p 27616</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ben@ben:~$ ssh</span><br><span class="line">usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]</span><br><span class="line">           [-D [bind_address:]port] [-E log_file] [-e escape_char]</span><br><span class="line">           [-F configfile] [-I pkcs11] [-i identity_file] [-L address]</span><br><span class="line">           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]</span><br><span class="line">           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]</span><br><span class="line">           [-w local_tun[:remote_tun]] [user@]hostname [command]</span><br></pre></td></tr></table></figure>

<h4 id="Texlive2015与Texstudio"><a href="#Texlive2015与Texstudio" class="headerlink" title="Texlive2015与Texstudio"></a>Texlive2015与Texstudio</h4><ol>
<li>Texlive2015安装<br>因为windows 7下用的Texlive2015，很多文档基于此编译的</li>
<li>1 安装per组件<br><code>sudo apt-get install perl-tk</code></li>
</ol>
<blockquote>
<p>加载镜像组件（我挂在的是移动硬盘，到其目录下）<br><code>sudo mount -o loop texlive2015.iso /mnt</code></p>
</blockquote>
<blockquote>
<p>启动安装程序的图形化界面进行配置 (我默认安装在ssd上了)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;mnt </span><br><span class="line">sudo .&#x2F;install-tl -gui</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设置环境变量<br><code>sudo gedit ~/.bashrc</code></p>
</blockquote>
<p>==根据安装路径==末尾加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export MANPATH&#x3D;$&#123;MANPATH&#125;:&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2015&#x2F;texmf-dist&#x2F;doc&#x2F;man</span><br><span class="line">export INFOPATH&#x3D;$&#123;INFOPATH&#125;:&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2015&#x2F;texmf-dist&#x2F;doc&#x2F;info</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2015&#x2F;bin&#x2F;x86_64-linux</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Texstudio<br>这款编辑器比较像winedt，所以我就直接在ubuntu 16.04软件中心直接安装了，需要注意的点在于如何配置</li>
</ol>
<p>TexStudio 中: option-&gt; configure texstudio-&gt; commands -&gt; latex/ pdflatex/ xelatex/ luralatex … 等到成功配置好这些命令的位置即可成功运行 TexStudio 并生成 pdf 文件了。</p>
<p>还存在的一个小问题是对于 eps 的图片格式会报错 XeLaTex xdvipdfmx:fatal: pdf_ref_obj(): passed invalid object ,而如果直接在终端的命令行中利用 xelatex 编译生成 pdf 文档则没有任何问题。解决的方法可以参考<a href="http://www.cnblogs.com/docnan/p/7103599.html?utm_source=itdadao&utm_medium=referral" target="_blank" rel="noopener" title="Latex加速:TexStudio的安装和使用-DocNan-博客园">Latex加速:TexStudio的安装和使用-DocNan-博客园</a>,也就是把 TexStudio ==在高级设置中的搜索路径直接替换成 TexLive 软件库中执行文件所在文件夹的路径==,在我的系统上就是: /usr/local/texlive/2015/bin/x86_64-linux ,这样设置之后果然没有任何问题了。估计还有一种可能性是经过这里搜索路径的更换,之前需要手动配置的 pdflatex, xelatex 等执行文件的位置也不用手动设了,但是此处 TexStudio 已经可以用了,就不做这个测试了。</p>
<p><del>@[图文参考pdf](file:/home/ben/下载/Latex加速_ TexStudio的安装和使用 - DocNan - 博客园.pdf)</del></p>
<ol start="3">
<li>中文字体<br>CJK相关包中文支持<br><code>sudo apt-get install latex-cjk-chinese ttf-arphic-* hbf-*</code></li>
</ol>
<p>不过,为了得到更好地支持,常常会使用Windows既有的TrueType字体或者文泉驿字体,以便扩充现有的系统字体库。<br>对于Linux,安装fontforge可以方便地生成能被Latex识别的字体文件(map、enc等文件)<br><code>sudo apt-get install fontforge</code></p>
<p><a href="http://blog.csdn.net/bensnake/article/details/43279329" target="_blank" rel="noopener" title="Ubuntu14.04/14.10系统安装Latex及配置中文字体[修订]-CSDN博客">Ubuntu14.04/14.10系统安装Latex及配置中文字体[修订]-CSDN博客</a></p>
<ol start="4">
<li>配置完遇到的一些问题<blockquote>
<p>毕业大论文texstudio打开中文乱码(从windows下拷贝到ubuntu)<br>gedit 打开拷贝到乱码的texstudio编辑器保存</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>毕业论文beamer texstudio打开无乱码(从windows下拷贝到ubuntu)<br>猜想：或许由于windows下的beamer采用了utf-8编码(Encodings)，而4.1中windows下的则采用了gbk，建议采用utf-8</p>
</blockquote>
<h4 id="Mathematica11-0与MATLAB2015b安装"><a href="#Mathematica11-0与MATLAB2015b安装" class="headerlink" title="Mathematica11.0与MATLAB2015b安装"></a>Mathematica11.0与MATLAB2015b安装</h4><ol>
<li>Mathematica11.0<br>由于学校pt上只有version11.0的mathematica的包，所以我下载至移动硬盘，挂在至系统，进入sh文件目录</li>
<li>1 安装<br><code>sudo sh Mathematica.sh</code></li>
</ol>
<blockquote>
<p>激活<br>安装完毕，在dash中搜索mathematica打开，类似与windos激活即可。</p>
</blockquote>
<ol start="2">
<li>Matlab R2015b_glnxa64.iso and Crack files<br>挂载iso至linux /mnt下<br><code>sudo mount -o loop R2015b_glnxa64.iso /mnt</code></li>
</ol>
<p>cd进2015b iso文件目录<br><code>sudo ./install</code></p>
<p>激活<br><a href="http://blog.csdn.net/hejunqing14/article/details/50265049" target="_blank" rel="noopener" title="linux(x64)下安装Matlab2015b破解版(含安装包)">linux(x64)下安装Matlab2015b破解版(含安装包)</a></p>
<p>运行<br><code>cd /usr/local/MATLAB/R2015b/bin</code></p>
<p><code>sudo ./matlab</code></p>
<h4 id="Eclipse-for-C-C-developer"><a href="#Eclipse-for-C-C-developer" class="headerlink" title="Eclipse for C/C++ developer"></a>Eclipse for C/C++ developer</h4><p>因为C语言的eclipse for c/c++ ide环境依赖于java环境，所以我们先安装这个，我已经在官网下载好并且放入移动硬盘了</p>
<ol>
<li>安装jdk环境<br>我下载的是jdk-8u151-linux-x64.tar.gz，将其放入/opt目录, 执行解压<br><code>tar -zxvf  jdk-8u151-linux-x64.tar.gz</code></li>
</ol>
<p>配置jdk的环境变量，打开 /etc/profile文件（sudo vim /etc/profile），在文件末尾添加下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;opt&#x2F;jdk1.8.0_151</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<p>查看是否安装成功：<code>java -version</code> 出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java version &quot;1.8.0_151&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_151-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装eclipse<br>我下载的是eclipse-cpp-neon-3-linux-gtk-x86_64.tar.gz,解压至/opt目录<br><code>sudo tar zxvf eclipse-jee-mars-2-linux-gtkeclipse-cpp-neon-3-linux-gtk-x86_64.tar.gz -C /opt/</code></li>
</ol>
<p>解压完可以运行，也可以参考<a href="http://blog.csdn.net/guolongpu/article/details/59501726" target="_blank" rel="noopener" title="ubuntu 搭建 eclipse c Ubuntu 16.04LTS中搭建Eclipse Neon2 [Eclipse IDE for C/C++ Developer]">ubuntu 搭建 eclipse c Ubuntu 16.04LTS中搭建Eclipse Neon2 [Eclipse IDE for C/C++ Developer]</a>先制作快捷启动图标. 这篇博客也教了大家怎么第一次使用eclipse for c来编译c程序, 测试安装是否到位.</p>
<p>我是直接cd 进目录直接运行再将其锁定到启动器的.</p>
<p>==作为一个新手我对与这种解压就可以运行的安装包tar.gz很好奇，前面都是apt-get，aptitude，deb,sh，iso之类的安装，后续研究下这类包的性质.==</p>
<h4 id="一些生产力工具"><a href="#一些生产力工具" class="headerlink" title="一些生产力工具"></a>一些生产力工具</h4><ol>
<li>MATLAB 工具箱exportfig_fig——————加速写作插图<br>写作是一件很有意思的事情，尤其在Latex上写作，插入美美的插图简直会中毒。首先，如果插入的是位图绝对不能忍的(别问为什么，强迫症)！！！而如Matlab print 保存的矢量图存在白边，且不能保留matlab中的patch的透明度。</li>
</ol>
<p>无意中在git上发现了一个工具包export_fig结合ghostscript\Xpdf工具，就可以解决Matlab保存图片白边过大，且不能保留矢量图透明度的问题。令人惊喜的是Linux中已经配置了gs, Xpdf(装了tex缘故)</p>
<p><code>gs -h</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GPL Ghostscript 9.18 (2015-10-05)</span><br><span class="line">Copyright (C) 2015 Artifex Software, Inc.  All rights reserved.</span><br></pre></td></tr></table></figure>
<p>将export_fig添加进路径,测试:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plot(sin(linspace(0, 10, 1000)), &#39;b:&#39;, &#39;LineWidth&#39;, 4);</span><br><span class="line">hold on</span><br><span class="line">plot(cos(linspace(0, 7, 1000)), &#39;r--&#39;, &#39;LineWidth&#39;, 3);</span><br><span class="line">grid on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%export_fig test -eps</span><br></pre></td></tr></table></figure>
<h4 id="2-ImageMagick-图片互转-————-将gif转成png系列可以插入latex-beamer动画演示"><a href="#2-ImageMagick-图片互转-————-将gif转成png系列可以插入latex-beamer动画演示" class="headerlink" title="2.ImageMagick 图片互转 ————-将gif转成png系列可以插入latex beamer动画演示"></a>2.ImageMagick 图片互转 ————-将gif转成png系列可以插入latex beamer动画演示</h4><p>令人惊喜的是Linux中已经配置了ImageMagick(装了tex缘故)</p>
<p><code>convert cat.gif -coalesce cat_.png</code></p>
<hr>
<blockquote>
<p>配置大体就是这样了，主要用来写matlab/mathematica/c程序,以及通过terminal ssh管理raspberry网站服务器和web服务器.</p>
</blockquote>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>dev</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages 及hexo next博客搭建</title>
    <url>/posts/1b71e0af/</url>
    <content><![CDATA[<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><a id="more"></a>
<ol>
<li>安装稳定新的node和npm版本,以及hexo<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.35.2&#x2F;install.sh | bash #安装nvm</span><br><span class="line"></span><br><span class="line">nvm ls-remote #检查远程仓库</span><br><span class="line">nvm install stable #安装稳定版本</span><br><span class="line">nvm use node #启用安装好的版本</span><br><span class="line"></span><br><span class="line"># check version</span><br><span class="line">node -v </span><br><span class="line">npm -v </span><br><span class="line"></span><br><span class="line">test node</span><br></pre></td></tr></table></figure>
<code>npm install hexo-cli -g</code><br>用于预览(可选)<br><code>npm install hexo-server -g</code></li>
</ol>
<ol start="2">
<li>创建hexo site<br><code>cd /Data/workspace/git</code><br><code>mkdir blog</code><br><code>cd blog</code><br><code>hexo init</code></li>
</ol>
<blockquote>
<p>提示 You are almost done! Don’t forget to run ‘npm install’ before you start blogging with Hexo!</p>
</blockquote>
<p>  <code>npm install #安装依赖项</code><br>  <code>hexo server</code></p>
<blockquote>
<p>now we can visit localhost:4000 and create posts.</p>
</blockquote>
<h4 id="配置模版-喜欢next简洁风"><a href="#配置模版-喜欢next简洁风" class="headerlink" title="配置模版,喜欢next简洁风"></a>配置模版,喜欢next简洁风</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir themes&#x2F;next</span><br><span class="line">curl -s https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;iissnan&#x2F;hexo-theme-next&#x2F;releases&#x2F;latest | grep tarball_url | cut -d &#39;&quot;&#39; -f 4 | wget -i - -O- | tar -zx -C themes&#x2F;next --strip-components&#x3D;1</span><br></pre></td></tr></table></figure>

<h4 id="github"><a href="#github" class="headerlink" title="github"></a>github</h4><p><code>ssh-keygen -t rsa -C &#39;xxx@xxx.com</code><br><code>cat id_rsa.pub</code><br><code>ssh -T git@github.com #测试</code> </p>
<h4 id="deploy-to-github"><a href="#deploy-to-github" class="headerlink" title="deploy to github"></a>deploy to github</h4><p><code>npm install hexo-deployer-git --save #安装自动部署发布工具</code><br><code>npm install hexo-util -g</code><br><code>sudo gedit _config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo:   git@github.com:benlw&#x2F;benlw.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p> <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d #发布</code></p>
<h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p><code>ping benlw.github.io</code></p>
<blockquote>
<p>185.199.110.153</p>
</blockquote>
<p>最后,在仓库中设置CNAME内容<a href="https://5imcs.com">https://5imcs.com</a></p>
<h4 id="后续问题"><a href="#后续问题" class="headerlink" title="后续问题?"></a>后续问题?</h4><ol>
<li>Cannot Get /XXX</li>
</ol>
<blockquote>
<p>hexo new page “categories”</p>
</blockquote>
<p>2.<s>首页只显示标题,不显示摘要和内容<br>修改<code>\themes\next\layout_macro</code><br></s></p>
<ol start="3">
<li><p>about页面,<code>hexo new page about</code>然后在source目录下就会生成对应的文件夹,每个文件夹里都有一个index.md，打开将页面的type设置为相应的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: </span><br><span class="line">type: &quot;tags&quot; # 或者 &quot;categories&quot;&#x2F;&quot;about&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>-待解决</p>
</li>
</ol>
<ul>
<li><input checked="" disabled="" type="checkbox"> 侧边栏连接失效<blockquote>
<p>next升级7.7</p>
</blockquote>
</li>
</ul>
<ol start="5">
<li>在右上角或者左上角实现fork me on github,在这里选择喜欢的样式。这里选择的是</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;benlw&#x2F;benlw.github.io&quot; class&#x3D;&quot;github-corner&quot; aria-label&#x3D;&quot;View source on Github&quot;&gt;&lt;svg width&#x3D;&quot;80&quot; height&#x3D;&quot;80&quot; viewBox&#x3D;&quot;0 0 250 250&quot; style&#x3D;&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;path d&#x3D;&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;&#x2F;path&gt;&lt;path d&#x3D;&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill&#x3D;&quot;currentColor&quot; style&#x3D;&quot;transform-origin: 130px 106px;&quot; class&#x3D;&quot;octo-arm&quot;&gt;&lt;&#x2F;path&gt;&lt;path d&#x3D;&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill&#x3D;&quot;currentColor&quot; class&#x3D;&quot;octo-body&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;&lt;&#x2F;a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p>将其粘贴到themes/next/layout/_layout.swig中，放在div class=”headband”&gt;</div>下面</p>
<ol start="6">
<li>公式测试</li>
</ol>
<p>$$ \tau = J^T F$$</p>
<ol start="7">
<li>测试pdf<div class="pdf" target="/hexo/next-pdf/1.pdf" height=""></div><blockquote>
<p><a href="example.pdf">点我，这里是PDF文档</a></p>
</blockquote>
</li>
</ol>
<ol start="8">
<li>测试图片<br>注: next7主题已经可以不用安装hexo的image插件了.直接打开</li>
</ol>
<p><code>[1](1.png) #不引用</code></p>
<p><img src="1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 1.png This is an image %&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>hexo</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
</search>
