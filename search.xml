<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>变分积分子(一些数值算例)</title>
    <url>/posts/f60cbae0/</url>
    <content><![CDATA[<h4 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h4><p>目的:根据以下几篇论文提供的算法,尝试动手编写一下Matlab代码,跑几个例子加深一下理解.</p>
<ol>
<li>Variational Integrators and the Newmark Algorithm for Conservative and Dissipative Mechanical System,2000, C Kane</li>
<li>Hamilton–Pontryagin Integrators on Lie Groups,2008, JE Marsden</li>
<li>Hamel’s formalism and variational integrators on a sphere,2012, DV Zenkov</li>
<li>几何精确梁,2016,王亮</li>
<li>雪橇,2019,安志朋</li>
</ol>
<h5 id="VI-and-Newmark算法"><a href="#VI-and-Newmark算法" class="headerlink" title="VI and Newmark算法"></a>VI and Newmark算法</h5><p>论文说明了classical newmark algorithm在某种意义上是离散力学的变分版本,这样的算法是辛且动量守恒的.拥有较为出色的全局能量行为.其次论文基于Lagrange-d’alembert原理推导了非保守系统的离散变分算法.</p>
<p>数值算例主要基于section3,详细见the variational algorithm on $T^{\star}Q$.</p>
<p>考虑一个nonlinear oscillator, unit mass moving in the plane under influence of the potential $U(q) =q^2(q^2-1)^2.$</p>
<p>测试算法为 隐/显式newmark算法(h=0.2)以及VI $L_d^{sym,\alpha}$ 和R-K, Benchmark<br>算法采用matlab ode113.为了代码统一,我将其写为对$(q_k,p_{k})$的更新.相对于经典R-K,我调用了fsolve求解DEL方程.结果如下</p>
<p><img src="nmk.png" alt=""></p>
<h5 id="HP-integrators-on-Lie-Groups"><a href="#HP-integrators-on-Lie-Groups" class="headerlink" title="HP integrators on Lie Groups"></a>HP integrators on Lie Groups</h5><p>考虑势能函数$U_{\alpha}=(dist(Q,I)-1)^2-\frac{\alpha}{dist(Q,Q_t)}$</p>
<p>以Lie-Verlet method(牛顿法计算4.11a式)为例(h=0.125)</p>
<p><img src="vlv.png" alt=""></p>
<h5 id="Hamel’s-formalism-and-VI"><a href="#Hamel’s-formalism-and-VI" class="headerlink" title="Hamel’s formalism and VI"></a>Hamel’s formalism and VI</h5><p>待整理</p>
<h5 id="几何精确梁"><a href="#几何精确梁" class="headerlink" title="几何精确梁"></a>几何精确梁</h5><p>考虑重力作用下,并且一端固定的场景(<a href="code.zip">点我,相关代码</a>)<br><img src="example.jpg" alt=""></p>
<p>Hamel场方程如上,运算结果如下.</p>
<p><img src="testAnimated-withgravity.gif" alt=""></p>
<h5 id="雪橇"><a href="#雪橇" class="headerlink" title="雪橇"></a>雪橇</h5><p>待整理</p>
]]></content>
      <categories>
        <category>VI</category>
      </categories>
      <tags>
        <tag>动力学</tag>
      </tags>
  </entry>
  <entry>
    <title>读论文a linear-time VI</title>
    <url>/posts/e25dfb89/</url>
    <content><![CDATA[<p>论文预印地址:<a href="https://arxiv.org/abs/1609.02898" target="_blank" rel="noopener">[1609.02898] A Linear-Time Variational Integrator for Multibody Systems</a>  </p>
<p><a href="paper.pdf">点我，这里是PDF文档</a></p>
<p>论文代码地址:<a href="https://github.com/jslee02/wafr2016" target="_blank" rel="noopener">GitHub - jslee02/wafr2016: Implementation of “A Linear-Time Variational Integrator for Multibody Systems”</a></p>
<p>代码编译:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd build</span><br><span class="line">make -j8 experiments examples</span><br><span class="line">cd &lt;wafr2016_root_dir&gt;&#x2F;build&#x2F;bin</span><br><span class="line">.&#x2F;dm_passivePendulum</span><br></pre></td></tr></table></figure>

<p>代码运行结果(<code>numLinks=6</code>,<code>gravity=-9.81</code>,<code>h=(1.0/1000)</code>):</p>
<p><img src="experiment.gif" alt=""></p>
<p>注:</p>
<ol>
<li><a href="https://dartsim.github.io/" target="_blank" rel="noopener">DART: Dynamic Animation and Robotics Toolkit</a>:The library provides data structures and algorithms for kinematic and dynamic applications in robotics and computer animation.</li>
<li>Vrep:</li>
</ol>
<ul>
<li>bullet物理引擎(t = 24s,time step = 50ms):</li>
</ul>
<p><img src="bullet.gif" alt=""></p>
<ul>
<li>ode隐式格式(t = 24s,time step = 50ms)</li>
</ul>
<p><img src="ode.gif" alt=""></p>
<ol start="3">
<li><p><a href="note.pdf">这是我的笔记</a></p>
</li>
<li><p>另一篇较新的文献: <a href="https://arxiv.org/abs/1904.12756" target="_blank" rel="noopener">Efficient Computation of Higher-Order Variational Integrators in Robotic Simulation and Trajectory Optimization</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>VI</category>
      </categories>
      <tags>
        <tag>动力学</tag>
      </tags>
  </entry>
  <entry>
    <title>强化学习论文(multi-agent RL综述篇)</title>
    <url>/posts/5ad812f1/</url>
    <content><![CDATA[<hr>
<p>Review Papers(<a href="https://github.com/LantaoYu/MARL-Papers#review-papers" target="_blank" rel="noopener">GitHub - LantaoYu/MARL-Papers: Paper list of multi-agent reinforcement learning (MARL)</a>)</p>
<ul>
<li>Multi-Agent Reinforcement Learning: A Selective Overview of Theories and Algorithms by Kaiqing Zhang, Zhuoran Yang, Tamer Başar. 2019.</li>
<li>A Survey on Transfer Learning for Multiagent Reinforcement Learning Systems by Silva, Felipe Leno da; Costa, Anna Helena Reali. JAIR, 2019.</li>
<li>Autonomously Reusing Knowledge in Multiagent Reinforcement Learning by Silva, Felipe Leno da; Taylor, Matthew E.; Costa, Anna Helena Reali. IJCAI, 2018.</li>
<li>Deep Reinforcement Learning Variants of Multi-Agent Learning Algorithms by Castaneda A O. 2016.</li>
<li>Evolutionary Dynamics of Multi-Agent Learning: A Survey by Bloembergen, Daan, et al. JAIR, 2015.</li>
<li>Game theory and multi-agent reinforcement learning by Nowé A, Vrancx P, De Hauwere Y M. Reinforcement Learning. Springer Berlin Heidelberg, 2012.</li>
<li>Multi-agent reinforcement learning: An overview by Buşoniu L, Babuška R, De Schutter B. Innovations in multi-agent systems and applications-1. Springer Berlin Heidelberg, 2010</li>
<li>A comprehensive survey of multi-agent reinforcement learning by Busoniu L, Babuska R, De Schutter B. IEEE Transactions on Systems Man and Cybernetics Part C Applications and Reviews, 2008</li>
<li>If multi-agent learning is the answer, what is the question? by Shoham Y, Powers R, Grenager T. Artificial Intelligence, 2007.</li>
<li>From single-agent to multi-agent reinforcement learning: Foundational concepts and methods by Neto G. Learning theory course, 2005.</li>
<li>Evolutionary game theory and multi-agent reinforcement learning by Tuyls K, Nowé A. The Knowledge Engineering Review, 2005.</li>
<li>An Overview of Cooperative and Competitive Multiagent Learning by Pieter Jan ’t HoenKarl TuylsLiviu PanaitSean LukeJ. A. La Poutré. AAMAS’s workshop LAMAS, 2005.</li>
<li>Cooperative multi-agent learning: the state of the art by Liviu Panait and Sean Luke, 2005.</li>
</ul>
<p>一些awesome的paper(<a href="https://github.com/tigerneil/awesome-deep-rl#multi-agent" target="_blank" rel="noopener">GitHub - tigerneil/awesome-deep-rl: For deep RL and the future of AI.</a>)</p>
]]></content>
      <categories>
        <category>查文献</category>
      </categories>
      <tags>
        <tag>查文献</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人学,机器视觉与控制-MATLAB算法基础(动力学与控制篇)</title>
    <url>/posts/49286280/</url>
    <content><![CDATA[<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul>
<li>讨论串联机械臂的动力学与控制,在simulink上测试机器人三环控制,参考书为robotics,vision,and control,第二版.</li>
</ul>
<h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><ul>
<li>动力学方程</li>
</ul>
<h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><h5 id="independent-joint-control-独立关节控制"><a href="#independent-joint-control-独立关节控制" class="headerlink" title="independent joint control (独立关节控制)"></a>independent joint control (独立关节控制)</h5><p>机器人传动系统包括驱动器(电机)以及连接至杆的传动装置. 机器人关节控制的一种常见方法是将每个关节视作一个独立的控制系统, 使其精确跟随各自关节角度轨迹.由于作用在关节上重力,速度及加速度的耦合,摩擦力产生的各种干扰使得情况变得复杂. 所以, <font color=red>嵌套</font>的控制回路是一种常见的控制结构.<br>其outer loop(外环)负责保持关节位置(p),并确定使位置误差最小的关节速度(velocity of joint);inner loop(内环)负责保持外环所需的关节速度.</p>
<h6 id="Actuators"><a href="#Actuators" class="headerlink" title="Actuators"></a>Actuators</h6><p>如今多数机器人都是旋转电机(rotary electric motors)驱动的.大型工业机器人通常使用无刷伺服电机(brushless servo motors).而实验室多数使用直流有刷电机(brushed DC motors)或步进电机(stepper motors).采矿,林业或建筑业中大负载机械手通常使用液压驱动(electro-hydraulic).</p>
<p><img src="1.png" alt=""></p>
<p>电压$u$控制流入电机的电流$i_m$,产生转矩$\tau_m$,加速电机惯量$J_m$,其相对摩擦力记为$B_m\omega_m$.编码器测量转角及转速$\theta,\omega$.上图再接入齿轮箱,对于一个$G:1$的减速传动,连杆处扭矩应是电机扭矩$G$倍.</p>
<p>电机可以由电流或电压控制.我们假设由电机驱动或放大器(amplifier)提供电流. $i_m = K_a u$. 其中$K_a$为transconductance of amplifier,单位为$(AV^{-1})$ .电机产生的转矩正比与电流: $\tau_m = K_m i_M$.其中$K_m$为电机转矩系数,$(NmA^{-1})$.</p>
<h6 id="Friction"><a href="#Friction" class="headerlink" title="Friction"></a>Friction</h6><p>任何旋转的机械,电机或齿轮箱(gearbox)都受到摩擦力影响.电机净转矩为 $\tau’ = \tau_m- \tau_f$.其中$\tau_f = B\omega + \tau_C$. 其中$B&gt;0$为粘性摩擦系数(viscous friction coefficient), 偏移量为库伦摩擦力.后者由非线性函数建模. $\tau_C =  0, \omega = 0$,$\tau_C =  \tau^+_C , \omega &gt; 0$. </p>
<p>摩擦力系数取决与旋转方向,库伦摩擦的不对称性比粘性摩擦更明显.</p>
<p><img src="2.png" alt=""></p>
<p>在低速情况下(灰色区域),粘滞现象(stiction effect)明显.机器移动后,静摩擦迅速减小,粘性摩擦起主导作用.</p>
<h6 id="Effect-of-the-link-mass"><a href="#Effect-of-the-link-mass" class="headerlink" title="Effect of the link mass"></a>Effect of the link mass</h6><p>连杆对电机有两个显著影响,它增加了额外的惯性,并由于臂的重力增加了转矩,两者随关节位型而变化.以下图为例,考虑2-平面机械臂.第一连杆为红色,假设质量集中在质心处,额外的惯量(extra inertia)记为$m_1r_1^2$.电机还将受蓝色杆的影响,惯量取决于$q_2$–直臂的惯性大于折叠情况.</p>
<p><img src="3.png" alt=""></p>
<p>我们将看到作用在红色连杆质心处重力将在关节1电机上产生与$\cos{q_1}$正比的力矩.而在蓝色杆上的杠杠效应则更大.</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; mdl_twolink_sym</span><br><span class="line">&gt;&gt; syms q1 q2 q1d q2d q1dd q2dd <span class="built_in">real</span></span><br><span class="line">&gt;&gt; tau = twolink.rne([q1 q2], [q1d q2d], [q1dd q2dd]);</span><br></pre></td></tr></table></figure>

<p>$\tau_1 = M_{11}\ddot{q}+ M_{12}(q_2)\ddot{q_2} + C_1(q_2)\dot{q_1}\dot{q_2}+ C_2(q_2)\dot{q_2}^2+g(q_1,q_2)$,    (1)</p>
<p>$g = (a_1m_1+a_1m_2+c_1m_1)\cos(q_1)+ (a_2m_2+c_2m_2)\cos(q_1+q_2)$</p>
<p>我们可以通过课本提供的工具箱确定作用在每个关节的力矩(作为关节位置,速度,加速度的函数).</p>
<h6 id="Gearbox"><a href="#Gearbox" class="headerlink" title="Gearbox"></a>Gearbox</h6><p>电动机产生不了非常大扭矩.其输出转速可以非常高,因此配合齿轮减速装置来降低转速提高转矩.齿轮变速箱缺点是增加了成本,重量和摩擦噪声.许多高性能机器人会采用昂贵大扭矩电机直接驱动,或使用薄金属带而不是齿轮来获得一个非常低的传动比.</p>
<p><img src="4.png" alt=""></p>
<p>连杆惯性矩阵记为$J_l$.运动引起的力矩记为$\tau_d$.如上图.在参考系$l$测量值与$m$系下的参考值有关.</p>
<p>$^l\tau_C=G\cdot ^m\tau_C, ^l\omega = ^m\omega/G$.</p>
<p>从电机看,其惯性由2部分组成,其一是电机本身的旋转部分,即转子(rotor),记为$J_m$.该值在制造商数据手册中会提供.其二是可变的负载惯性$J_l$(variable load inertia),是动连杆(driven link)及连接到它的所有连杆惯性之和.对于关节$j$,它就是方程(1)构造的惯性矩阵元素$M_{jj}$.</p>
<h6 id="Modeling-the-robot-joint"><a href="#Modeling-the-robot-joint" class="headerlink" title="Modeling the  robot joint"></a>Modeling the  robot joint</h6><p>完整的电机驱动器包括产生转矩的电机,齿轮箱(gearbox,变速箱,放大转矩并减小负载的影响),编码器(位置,速度反馈).如下图</p>
<p><img src="5.png" alt=""></p>
<p>建立电机轴(motor shaft)力矩平衡方程(在参考系$m$下):</p>
<p>$K_mK_au- B’\omega -\tau’_C -\frac{\tau_d(q)}{G} = J’\dot{\omega}$,(2)</p>
<p>其中$B’,\tau’_C,J’$,</p>
<p>分别由电机,齿轮箱,和负载引起的有效总粘性摩擦,库伦摩擦和惯性.</p>
<p>$B’=B_m+ \frac{B_l}{G^2},J’=J_m+ \frac{J_l}{G^2}$.</p>
<p>为了分析(2),首先将其线性化: $B’\omega+J’\dot{\omega} = K_mK_au$.</p>
<p>再经Laplace变换: $sJ’ \Omega(s) + B’\Omega(s) =K_mK_aU(s)$. 其中$\Omega(s),U(s)$分别是时域信号$\omega(t),u(t)$的laplace变换.</p>
<p>将其改写为<fonn color=red>电机速度到控制输入&lt;\font&gt;的线性传递函数:$\frac{\Omega(s)}{U(s)} =  \frac{K_mK_a}{J’s+B’}$.</p>
<p>以puma 560第二个关节为例.在其它参数未给明情况下,取$B’ =B_m$,由$J’ =J_m+ \frac{J_l}{G^2}$可计算其有效惯量($M_{22}$随位型而变化,假设其为 $4.43kg/m^2$,则计算$J’ =5.8\times 10^{-4} kg/m^2$)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mdl_puma560</span><br><span class="line">syms qn</span><br><span class="line">tf &#x3D; p560.jointdynamics(qn);</span><br><span class="line">tf(2)</span><br><span class="line">&gt;&gt;</span><br><span class="line">ans &#x3D;</span><br><span class="line">            1</span><br><span class="line">  ----------------------</span><br><span class="line">  0.0005797 s + 0.000817</span><br><span class="line">Continuous-time transfer function.</span><br></pre></td></tr></table></figure>
<p> 一旦有了这种形式的模型,我们可以绘制阶跃响应(step response)并使用一系列标准控制系统设计工具.</p>
<h6 id="Velocity-control-loop"><a href="#Velocity-control-loop" class="headerlink" title="Velocity control loop"></a>Velocity control loop</h6><p> <font color=red>嵌套</font>的控制回路是一种常见的控制结构. 其outer loop(外环)负责保持关节位置(p),并确定使位置误差最小的关节速度(velocity of joint);inner loop(内环,速度环)负责保持外环所需的关节速度.电机速度控制对所有类型机器人都很重要,不仅仅是串联机械臂.例如第4章中所讨论的小车车轮速度和四旋翼转子速度.</p>
<p>simulink模型如下.电机驱动器输入为所需速度和实际速度误差.1ms延迟用来模拟速度控制算法的计算时间,而饱和器(saturator)模拟电机提供的最大力矩.</p>
<p><img src="6.png" alt=""></p>
<p><img src="7.png" alt=""></p>
<p>考虑比例控制情况$K_i=0$, $u^* =K_v(\dot{q}^*-\dot{q})$.其中输入$\tau_d$用于模拟作用在关节上的干扰力矩.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vloop_test</span><br></pre></td></tr></table></figure>

<p>经过少量实验, 当$K_v=0.6$可获得满意的性能.在不连续处会有轻微过冲(overshoot),但增益越小,会导致速度误差越大,而增益对大,会导致振动(oscillation),控制工程需要权衡.</p>
<p>从实验结果(运行上述代码)来看,可观察到非常小的稳态误差(steady-state Error)-实际速度始终低于要求.从经典控制系统角度来看,速度环不包括积分模块(integrator block),并且归类为0类系统(type 0 system,对于恒定输入表现出有限的误差).更直观说,为了以恒定速度移动,电机必须产生有限的力矩来克服摩擦,由于电机力矩与速度误差成正比,因此存在有限速度误差.</p>
<p>接下来我们研究惯性变化对闭环控制的影响.结果显示对于8连杆惯性,不稳定,对于较大的惯性,跟踪误差衰减.</p>
<h6 id="Position-control-loop"><a href="#Position-control-loop" class="headerlink" title="Position control loop"></a>Position control loop</h6><h6 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h6><h5 id="Rigid-body-dynamics-compensation"><a href="#Rigid-body-dynamics-compensation" class="headerlink" title="Rigid body dynamics compensation"></a>Rigid body dynamics compensation</h5><h6 id="Feedforward-control"><a href="#Feedforward-control" class="headerlink" title="Feedforward control"></a>Feedforward control</h6><h6 id="Computed-torque-control"><a href="#Computed-torque-control" class="headerlink" title="Computed torque control"></a>Computed torque control</h6><h6 id="Operational-space-control"><a href="#Operational-space-control" class="headerlink" title="Operational space control"></a>Operational space control</h6><h5 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h5><h5 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h5>]]></content>
      <categories>
        <category>动力学</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>simulink</tag>
      </tags>
  </entry>
  <entry>
    <title>读论文continuous control with deep reinforcement learning并测试walking robot学习实例</title>
    <url>/posts/1080553f/</url>
    <content><![CDATA[<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul>
<li>许多物理任务具有连续且高维的动作空间. google Deepmind(DDPG.论文算法)使用actor-critic结构,用于连续动作的预测.</li>
<li>以walking robot为例,训练其走直线并保证最省能量控制.</li>
</ul>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul>
<li>RL(见补充:1)</li>
</ul>
<p>可解决一些非常困难的控制问题(无人机,机器人).与其它使用静态数据集学习框架(无监督\有监督)不同,RL与动态环境交互,旨在找到”收集奖励最多”的动作序列.</p>
<p>假设agent里有一个大脑,它接收状态观测observations,输出动作.这种映射称为policy.如果提供一组观测量,策略便会确定要采取的动作.如果将策略表示为神经网络,则可以让agent一次接收上千输入状态,并给出有意义的动作.当环境不断变化,这种”策略”不再最优或无法映射到有效动作,强化学习算法RL—(根据采取的行动,从环境中观察的结果以及所获得的奖励reward,<br>,update)–&gt;policy. 从而使得给定任何状态,agent都可以采取最有利的动作以产生最多的奖励累计.比如这次没考好,贪玩了,则调整策略,下次好好学习.</p>
<p>强化学习核心是优化问题(让计算机自主学习优化参数,”反复试错”).<br>基本关键词有: policy,state,action,reward(特定状态下的instantaneous奖励), value(从该状态到未来的全部奖励)等…所以一般评估状态的价值,而不是评估奖励(见Q-learning中的Q表更新方式),这样可以帮助agent选择一段时间内可获得的最优奖励的动作(而非短期利益).</p>
<p>基本分类:policy function based(如policy gradients方法), value function based(Q-learning), actor-critic based(DDPG,论文采用).</p>
<center>
<pre class="mermaid">graph LR
    A[Policy <br> RL]-->|Actions| B[states <br> reward]
    B-->|Reward| A
    B-->|State Observations| A</pre>
</center>

<p>关于model-free(agent doesn’t need to know anything about the environment at all)和model-based(we know what’s not worth exploring)</p>
<p>优缺点: 大量样本,大量试错….如何理解神经网络的权重和偏差值,如果策略不符合规划,如何调整这个策略.把所有函数压缩在一个黑盒子,一旦出现问题,很难手动定位到出问题的点,无法解释输出为何这样.</p>
<ul>
<li><font color=red>Q学习</font> (Q表记录潜在奖励,以学生写作业为例,a1–看电视, a2–写作业)</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>a1</th>
<th>a2</th>
</tr>
</thead>
<tbody><tr>
<td>s1</td>
<td>-2</td>
<td>1</td>
</tr>
<tr>
<td>s2</td>
<td>-4</td>
<td>2</td>
</tr>
</tbody></table>
<p>关键: 如何更新?</p>
<p>根据Q表的估计,在s1状态采取了a2(写作业),并到达了a2状态,这时开始更新决策Q表: 想象在s2中采取行为,分别看哪种行为对应Q值大.</p>
<p>比如说Q(s2,a2)比Q(s2,a1)大(预估的).我们将$\gamma* maxQ(s2,a’) + r$ (最大的Q乘以衰减值 + 达到s2所获奖励),因为这里获得实际的奖励,于是将其作为现实Q(s1,a2)的值.之前的Q(s1,a2)为估计值.</p>
<p>注: Bellman方程的表现形式，它表明了当前状态s下Agent所能够获得的期望回报值与其后继状态之间存在关联.</p>
<p>有了现实与估计值,就能更新Q(s1,a2):</p>
<p>$ Q(s,a)=Q(s,a)+\alpha*[r+\gamma*maxQ(s’,a’)-Q(s,a)] $($\alpha$学习效率).</p>
<p>算法流程:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initial Q(s,a)</span><br><span class="line">repeat(for each episode):</span><br><span class="line">	initial s</span><br><span class="line">	repeat(for each step of episode):</span><br><span class="line">		choose a from s using policy derived from Q (eg: epsilon greedy)</span><br><span class="line">		take a, observe r,and s&#39;</span><br><span class="line">		$ Q(s,a)&#x3D;Q(s,a)+\alpha*[r+\gamma*maxQ(s&#39;,a&#39;)-Q(s,a)] $</span><br><span class="line">		s &#x3D; s&#39;</span><br><span class="line">	until s is terminal</span><br></pre></td></tr></table></figure>

<p>一个例子: —O—–| (O代表人,|表示宝藏,训练它快速发现宝藏) 视频链接:<a href="https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/2-1-general-rl/" target="_blank" rel="noopener">^1</a></p>
<ul>
<li><font color=red>DQN(Deep Q network,2013,deepmind)</font>, 针对具有高维observation spaces以及离散且低维action sapces的agent训练,比如: 训练计算机玩电子游戏(离散的按键动作). </li>
</ul>
<p>关键: 融合了神经网络和Q-学习</p>
<p>Q学习用表格存储状态及其行动所拥有的Q值.当状态非常多时,如下围棋,计算机内存不够.</p>
<p>解决方法: </p>
<ol>
<li>利用神经网络,将状态s和动作a作为神经网络的输入,经分析得到(s,a)的Q值.这样一来就没必要继续在表格中记录Q值. 神经网络相当于眼鼻口接受外部信息,经大脑加工输出每种动作a的值,通过强化学习的方式选择动作.</li>
<li>更新神经网络, 训练样本怎么来? 采取的做法是用Q-学习中的Q现实值表示正确的Q值,神经网络的参数通过旧神经网络的参数+学习率*(Q现实-Q估计)来更新.</li>
<li>通过神经网络预测Q(s’,a’)值.选取Q最大相应的动作来获取环境的reward.</li>
<li>Experience replay:将系统探索环境数据储存起来.然后随机采样样本更新神经网络的参数.</li>
</ol>
<ul>
<li><font color=red>policy gradients</font> 论文链接:<a href="https://papers.nips.cc/paper/1713-policy-gradient-methods-for-reinforcement-learning-with-function-approximation.pdf" target="_blank" rel="noopener">^2</a></li>
</ul>
<p>上述两种方法主要是根据奖惩值,学习正确行为.如果是在无穷多(连续)动作中计算价值,吃不消.</p>
<p>思路: 通过神经网络分析,选取行为,再利用奖惩(不求导情况下),在神经网络反向传播中,左右下次被选的可能性.</p>
<p>例子: CartPole(传统强化学习任务之一:控制倒立摆): <a href="https://gym.openai.com/envs/CartPole-v0/" target="_blank" rel="noopener">^3</a> (注:其实DQN方法也能解决,将任务简化为cart只有离散动作R,L,状态为杆的位置及速度,但如果对倒立摆施加连续的扭矩这种方法就不合适了)</p>
<p>reward = $(-\theta^2-\dot{\theta})^2 $</p>
<h4 id="论文思路"><a href="#论文思路" class="headerlink" title="论文思路"></a>论文思路</h4><ul>
<li>DDPG(deep determinstic policy gradient, actor-critic)</li>
</ul>
<p>在控制中我们需要连续的动作空间,就像对倒立摆问题施加连续的力矩.将policy function based,value function based两种技术合并到一类称为执行-评价器(actor-critic)的算法中,其中执行器<br>是一个network,试图采取它认为当下状态最好的动作,评价器network则试图估计状态的价值和执行器采取的行动. </p>
<center>
<pre class="mermaid">graph LR
    C[Observations]-->A[Actor]
    C-->B[critic]
    B-->|Value|D[Compare]
    A -->|Actions|E[Environment]
    E-->|Reward|D</pre>
</center>
适用于连续动作空间,因为critic只需要查看一个动作,而不是试图通过评估所有动作.基本原理为,Actor采取与策略函数相同的方法(见policy gradient)选择动作.评价器则预估它认为状态-动作的值,然后使用环境反馈的奖励来确定它预测的价值准确程度,之后再类似神经网络的反向传播进行自我更新.Actor调整将来再次采取该动作的概率.(该策略会沿着评价器建议的方向进行梯度上升,执行器从评价器反馈中学习正确的动作,从而了解动作好坏.评价器从所获得奖励中学习价值函数,以便正确评价执行器采取的动作).agent利用策略和价值函数算法的最佳部分.A-C能处理连续状态和动作空间.

<p>最后可将优化的静态策略部署到物理环境中,也可以选择将RL算法一并部署以继续学习.</p>
<h4 id="walking-robot例子-model-based-可从Matlab文件中心下载该实例-视频讲解及源码-4"><a href="#walking-robot例子-model-based-可从Matlab文件中心下载该实例-视频讲解及源码-4" class="headerlink" title="walking robot例子 (model-based) 可从Matlab文件中心下载该实例. 视频讲解及源码^4"></a>walking robot例子 (model-based) 可从Matlab文件中心下载该实例. 视频讲解及源码<a href="https://www.mathworks.com/videos/deep-reinforcement-learning-for-walking-robots--1551449152203.html" target="_blank" rel="noopener">^4</a></h4><p>从传统控制角度:</p>
<p>observations(eg: camera images) -&gt; feature extraction -&gt; state estimation( other sensors) -&gt; control(blance, leg.motor control…) -&gt; 行走 </p>
<p>从RL(end-to-end)角度:</p>
<p>observations -&gt; (Black Box) -&gt; motor command</p>
<ul>
<li>分析:</li>
</ul>
<ol>
<li><p>actions(torque)<br>left-right ankle\knee\hip, 机器人躯干\腿和其所处世界构成环境.</p>
</li>
<li><p>observations<br>来自环境的观测值,基于传感器的类型和位置.本例中有31个观测值,具体包括躯干的Y,Z轴坐标值,沿X,Y,Z方向躯干速度,躯干旋转角度和角速度,以及6个关节的角度\角速度,脚与底面接触力.以及反馈上个时间步输出的力矩指令.</p>
</li>
</ol>
<p>控制系统(RL agent)接受31观测值,并且连续不断计算6个力矩.它使用一个actor将31观测值映射到6个力矩动作,以及一个评价器让执行器更有效率.</p>
<ul>
<li>工作流程</li>
</ul>
<ol>
<li>设置具有足够参数的策略.</li>
</ol>
<p>A-C神经网络.</p>
<ol start="2">
<li>选择reward来奖励良好的控制.</li>
</ol>
<p>reward = $v_x+ 0.00625-50*z^2 - \sum(\tau_i^2) + -3y^2$</p>
<ol start="3">
<li>选择RL算法观察(s,a),以及调整参数(traning过程).</li>
</ol>
<p>DDPG</p>
<h4 id="继续研究的方向"><a href="#继续研究的方向" class="headerlink" title="继续研究的方向"></a>继续研究的方向</h4><ol>
<li>最优控制结果作为样本训练神经网络?</li>
<li>用神经网络来训练轨迹规划参数?(已有不少文献)</li>
<li>流形学习? (流形学习估计柔性臂位姿)</li>
</ol>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ol>
<li><a href="https://ww2.mathworks.cn/videos/series/reinforcement-learning.html" target="_blank" rel="noopener">https://ww2.mathworks.cn/videos/series/reinforcement-learning.html</a> <a href="https://www.bilibili.com/video/BV1Gg4y1v7TR?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Gg4y1v7TR?p=2</a></li>
<li><a href="https://www.davidsilver.uk/teaching/" target="_blank" rel="noopener">https://www.davidsilver.uk/teaching/</a> </li>
<li>3BlueBrown(神经网络)<br><a href="https://www.bilibili.com/video/BV1bx411M7Zx?from=search&amp;seid=3993471132113230062" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1bx411M7Zx?from=search&amp;seid=3993471132113230062</a></li>
</ol>
]]></content>
      <categories>
        <category>Deep Reinforcement Learning</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>effective sampling in SE(3)</title>
    <url>/posts/e9246c12/</url>
    <content><![CDATA[<h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><ul>
<li>在$\rm SE(3)$定义合适的距离,采样函数,以及采样点插值.</li>
</ul>
<p>参考[1] </p>
<h5 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h5><ol>
<li>对$\rm SO(3)$均匀采样(欧拉角,四元数)</li>
</ol>
<p><img src="sampling_sphere.png" alt=""></p>
<ol start="2">
<li>Distance metics on $\rm SE(3)$ and geodesic interpolation function for rotations.</li>
</ol>
<p><img src="checkinterpolation.png" alt=""></p>
<h5 id="一个数值小实验"><a href="#一个数值小实验" class="headerlink" title="一个数值小实验"></a>一个数值小实验</h5><p>考虑22自由度蛇形机械臂的路径规划问题,采用RRT算法:</p>
<p><img src="result_withobs_rrt.png" alt=""></p>
<p>注:</p>
<ul>
<li><b>$\rm SE(3)$上的快速搜索随机生成树</b></li>
</ul>
<p>1.记初始位姿 $Q_0\in \rm SE(3)$  为随机树 $T$ 根结点.</p>
<p>2.预先给定某阈值 $p \in (0,1]$  . 随机生成某数 $p_c \in (0,1)$ , 若 $p_c\leq  p$, 则在工作空间中随机采样, 采样点记为 $Q_{rand}$ ; 否则直接取定目标位姿为采样点 $Q_{rand}$ .树$T$中距离${Q_{rand}}$ 最近的结点记为 $Q_{father}$, 记由 $Q_{father}.{x}$指向 ${Q_{rand}}.{x}$方向上步长为$p_{step}$处的结点为$Q_{new}.{x}$.</p>
<p><font color = red>$Q_{new}.R$可利用四元数与旋转矩阵的关系插值给出, 其中$Q_{<em>}.{x}$和$Q_{</em>}.{R}$分别表示采样点$Q_{*}$位置和姿态.</font> </p>
<p>3.若机械臂位姿$Q_{new}$不与障碍物发生碰撞, 则将$Q_{new}$插入树$T$. </p>
<p>重复采样直至$T$到达目标位姿, 从而获得一条由${Q_0}$到目标位姿${Q_d}$的规划路径.</p>
<ul>
<li><b>如上图,数值小实验可优化的空间在于</b></li>
</ul>
<ol>
<li>do smoothing before using the path.从上图可以看到,RRT的路径不光滑,也存在走”弯路”的情况.所以在应用时,应该考虑对路径做一些处理,如shortcutting,其思路是:随机连接生成树路径的采样点,如果该’线段’可行,则更新到路径中”.</li>
</ol>
<p>具体的,参见 see: <a href="http://www.osrobotics.org/osr/planning/post_processing.html" target="_blank" rel="noopener">http://www.osrobotics.org/osr/planning/post_processing.html</a> </p>
<p>[1]: Effective sampling and distance metrics for rigid body path planning</p>
<!--![](file.pdf)-->

<!--<div class="pdf" target="file.pdf" height=""></div> -->


]]></content>
      <categories>
        <category>sampling</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>读论文path planning and collision avoidance for robots并仿真</title>
    <url>/posts/c7ca1a9b/</url>
    <content><![CDATA[<h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><ul>
<li>通读论文并实现论文的例子</li>
</ul>
<p><img src="scene.png" alt=""></p>
<ul>
<li>搭建一个基本的框架(包含问题描述,障碍物避障准则(代数层面),离散,B-spline,SQP等部分),将其仿真实现,并可应用于n-dof的机械臂.</li>
</ul>
<p>仿真如下:</p>
<p>论文$t_f$最优时间为0.4261s, Matlab返回(局部?)最优解为0.4412</p>
<p><img src="testAnimated.gif" alt=""></p>
<p><font color=red>这篇文章对于最优控制的框架[^1]值得学习,尤其利用代数将避障处理成不等式约束,再利用隐面剔除策略减少约束.本文在前面newton-euler dynamics算法的基础上,结合B样条将问题离散,简单(在未引入隐面剔除策略下,调用<code>fmincon</code>函数)实现论文的optimal time数值算例.</font></p>
<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h5><ol>
<li>动力学方程</li>
</ol>
<p>可参考上一篇博文,这部分算法已经在Vrep中验证过了.简单验证一下是否和论文的一样 p462 </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% grav = inversedyn(robot.thetalist, zeros(3, 1), zeros(3, 1) ,robot.g, robot.T, robot.InertiaMtr, robot.Twist)</span></span><br><span class="line"><span class="comment">% k = -9.81;</span></span><br><span class="line"><span class="comment">% F_q_u = [0; -k*l*cos(robot.thetalist(2))*(0.5*m2+m3+m4)-k*l*cos(robot.thetalist(2)+robot.thetalist(3))*(0.5*m3+m4);...</span></span><br><span class="line"><span class="comment">%             -k*l*cos(robot.thetalist(2)+robot.thetalist(3))*(0.5*m3+m4)]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 核对无误 但是输入文章fig9的u1,u2,u3输入进去,杆1不怎么移动,这里应该是论文fig9有问题,我们将其乘以scaling factor 100. aha,作者回复我了,说忘记在论文提fig9是经过normalized,实际边界在-100~100Nm.此外,作者建议不要考虑重力(insufficient control 将导致robot崩溃 - -),关于初值的选取作者建议除了论文中的scaling方法,还可以从无障碍物开始训练,以constructing good initial guess.本博文也将采用这一策略.</p>
</blockquote>
<ol start="3">
<li>避障准则</li>
<li>B-spline 直接离散化</li>
<li>SQP</li>
<li>隐面剔除策略</li>
</ol>
<h5 id="序列二次规划-SQP"><a href="#序列二次规划-SQP" class="headerlink" title="序列二次规划(SQP)"></a>序列二次规划(SQP)</h5><p>因为时间有限,本此仿真将利用Matlab优化函数处理离散最优问题.先对<code>fmincon</code>有个大概了解.后续腾出手来再补充SQP.</p>
<p>作为Nonlinear programming solver,求解如下形式:<br>$$ min_x f(x) ~ s.t : c(x)\leq 0, ceq(x) = 0, A\cdot x \leq b, Aeq\cdot x = beq, and, lb \leq x \leq ub  $$</p>
<h5 id="开发进度"><a href="#开发进度" class="headerlink" title="开发进度"></a>开发进度</h5><ul>
<li><p>spline_curve(torque_grid_point, t, order, knot_vector),样条离散,输入 $t \in [0,1]$ 计算torque. 关于初值的选取我问了论文作者,他说如果没记错的话,对于torque control取了21个控制点(de boor point), 一阶样条,与auxiliary control $\omega$一致.</p>
</li>
<li><p>边界约束</p>
</li>
</ul>
<p>$$u(t)\in U: = {u\in \mathbb{R}^m | u_{min} \leq u \leq u_{max} }$$</p>
<p>$$ \omega_{i,k} \geq 0, for~ i = 1,…,12, k = 1,…,21 $$ </p>
<p>(为和论文保持统一,只考虑load和obstacle,每个cuboid六个面, 共12次, 时间节点划分为21个.)</p>
<ul>
<li>关于线性等式约束和线性不等式约束.</li>
</ul>
<p>无. </p>
<ul>
<li>关于非线性等式约束和非线性不等式约束.</li>
</ul>
<p>粗略一看,边界约束属于线性等式约束,在这个离散最优问题上,我们对动力学方程离散有两种方式: 1.由各时间节点 joint angle进行样条离散,2.是按论文的,对control进行离散.</p>
<p>从动力学方程的角度,似乎不太好按第一种方式进行离散,因为时间最优控制一般是bang-bang控制,关节轨迹一般需要比较高阶的样条(但在initial_guess时会更直观一点吧?).不过结果应该差不多吧,按这种方式离散, 上述边界约束则是非线性约束.</p>
<p>我还是按论文走.对control离散之后,调用正动力学计算$\ddot{\theta}$,选择合适的积分策略(这里简单选择euler显示格式,因为步长划分比较多).再调用正运动学计算负载位姿$T_{load} = [R,p;0 0 0 1] $,得到离散后避障约束方程(P444,OCP Problem)以及关节边界约束:</p>
<p>$$   G_I(x_k(z))^T w_I,h(t_k) =  0, I = 1,…,M=12,~~ K = 0,…,N $$<br>$$   g_I(x_k(z))^T w_I,h(t_k) &lt;= -e $$<br>$$   \phi(x_o,x_N(z)) = 0; $$</p>
<p>在程序中我设置了两个模式,以便切换.</p>
<blockquote>
<p><code>robot.collision_mode = 0; %false = 0 默认不考虑</code>, 进行最省时间路径规划</p>
</blockquote>
<blockquote>
<p>Q1.错误使用 barrier<br>Nonlinear constraint function is undefined at initial point. Fmincon cannot continue.</p>
</blockquote>
<p>遇到这个问题需要检查一下,调用<code>nonlinear_constraint(initial_guess)</code> 看是不是有NaN.(问题主要出在计算正动力学时 $ M $ 矩阵奇异.这与我们初值选取有关,如果想要避免这一问题,初始值可以稍微小一点.)</p>
<blockquote>
<p>Q2.Local minimum found that satisfies the constraints. 弄了个乌龙,返回满足局部最优,于是将其绘制轨迹曲线,发现都为0, 才发现最优化问题改变了x(1:6,1)这几个值,边界条件得管好呀..</p>
</blockquote>
<!--未经过任何优化,运行1min左右,得到了一个(忽略障碍)局部(非bang-bang,应该还有继续优化空间)最优时间解.<font color=red>如下</font>

![](release_1_without_obstacles.png) -->

<p> 有了这么个解之后,可以做很多事情了.</p>
<blockquote>
<p>关于为什么将$[0,tf]$转化到$[0,1]$</p>
</blockquote>
<p>如果我没理解错的话,除了为了分析Hessian之外,在编程中我发现,如果tf过大,划分步长不够的话,<code>forwardynamics</code>函数容易积累误差.想必这也是论文作者敢划分21点的原因,平均下来步长也就0.05,perfect!</p>
<ul>
<li>局部最优与全局<blockquote>
<p>探讨一下全局的策略.待完善. 涉及SQP一些技术手段,待后面再讨论. 本文仅在运行程序时做一些小记录.</p>
</blockquote>
</li>
</ul>
<p>在训练initial guess的时候, 训练到了<code>iter = 10</code>,从下午六点到晚上八点半才训练出一个较好的初值.这次优化包括了<code>6+ 3*21 + 12*21 + 1</code>个变量,其实应该像论文中所采取的做法,将Hessian输入到sqp求解中,能有效提高计算效率.经过我的测试,一个good initial guess可以将计算缩短,我在目标函数中加入了惩罚项 $\alpha||norm(\omega_i)||$,可以稍微提高鲁棒性.</p>
<p><font color=red>对大于20维优化问题,不建议用Matlab <code>fmincon</code>,本笔记只做一个简单的测试.具体实践中,还应该吃透一些常用的优化算法,编写好优化问题的梯度与Hessian.</font></p>
<ul>
<li>exitflag</li>
</ul>
<p>-2: No feasible point<br>-1: The output function terminated the algorithm<br> 0: Iterations exceeded options.<br> 1: 某种情况达到了收敛. 具体见doc fmincon.</p>
<ul>
<li>数值结果</li>
</ul>
<p>与论文控制力有些差别,计算差异体现在积分策略,以及 $\omega$ 的边界条件上.</p>
<p>注: 经测试,选择相同fmincon的优化算法,matlab 2019b与2015b均可以跑到相同结果.</p>
<p><img src="Res.png" alt=""><br><img src="omega.png" alt=""><br><img src="res.png" alt=""></p>
<ul>
<li>关于梯度与Hessian阵.</li>
</ul>
<p>这是一个可以对论文改进的方向.博文到这里, 耗费一周时间总算完成了一个OCP问题小实验.</p>
<hr>
<h5 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h5><ul>
<li><input disabled="" type="checkbox"> 因为论文采用的是一阶样条, 为了精简计算, 可以使用表达式避免调用</li>
</ul>
<p>$$ u = u_i + \frac{(t- t_i)}{t_{i+1}-t_i}(u_{i+1}-u_i) , t \in [t_i-t_{i+1}] $$</p>
<ul>
<li><input disabled="" type="checkbox"> 编写程序贪快,可以将一些参数变量放到<code>main</code>函数.</li>
<li><input disabled="" type="checkbox"> 隐面剔除</li>
<li><input disabled="" type="checkbox"> Hessian矩阵</li>
<li><input disabled="" type="checkbox"> <a href="https://ww2.mathworks.cn/products/parallel-computing.html" target="_blank" rel="noopener">Parallel Computing Toolbox - MATLAB</a> 并行计算</li>
</ul>
<hr>
<p>参考文献</p>
<p>[^1]: path planning and collision avoidance for robots.</p>
<hr>
<p>补充</p>
<p>/release1.1_with_obstacles/ ReswithObs.mat 为 tf = 0.4412, exitflag = 2;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% ---引用</span><br><span class="line">load ReswithObs.mat</span><br><span class="line">initial_guess &#x3D; Res;</span><br></pre></td></tr></table></figure>
<p>./mainprogram_spline_dev.m 为 tf = 0.4248, exitflag = 1; </p>
<p><code>fmincon</code>在高维上做的并不是非常出色,用同伦的方法找初值是一个办法,这也是一个不断试错的过程.<br>但是如果可能,还应该对程序优化,如梯度与Hessian,剔除策略.</p>
]]></content>
      <categories>
        <category>optimal control</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>coordinate-invariant dynamics algorithm验证</title>
    <url>/posts/1e752288/</url>
    <content><![CDATA[<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul>
<li>以平面RRR三连杆和空间三连杆为例,通过选择两种标架(joint frame以及center of mass frame),实现坐标不变算法对机械臂正逆动力学仿真:包括对inertial matrix, energy的分析; </li>
<li>搭建一个基本的creatrobot函数(其中各link为cuboid),采用euler数值积分,将仿真可视化,并与商业软件V-rep对比(对比末端轨迹),在此基础上测试变分积分子.</li>
</ul>
<h4 id="Coordinate-invariant-algorithm"><a href="#Coordinate-invariant-algorithm" class="headerlink" title="Coordinate-invariant algorithm"></a>Coordinate-invariant algorithm</h4><p>criag的书采用的就是这一方法,李泽湘的新的lecture也加入了这部分内容,坐标系建立在关节处,这一点与Park不同.</p>
<!--起初研究这部分内容,我还产生了一个疑问,为了保证惯性矩阵Inertia Matrix的简洁优雅,所以计算是在center of mass这一标架上进行的,$\tau = F^T_iS_i$, 其中$S_i$为screw aixs of i joint expressed in {i} frame.那么$\tau$结果应该是施加在第i杆质心上的?

[^_^]: <https://robotics.stackexchange.com/questions/20249/newton-euler-inverse-dynamics-by-screw>

先说结果,从程序实验来看,其实两种方法实验结果一致(包括得到的力矩).

我还没有仔细证明,但思路应该是要利用质心Inertia Matrix是$I_b$,那么在关节处(frame {s})应为为$Ad^T_gI_b Ad_g$. -->
<!--
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Is</span> = <span class="title">inertialmatirx_check</span><span class="params">(T,Ib)</span></span></span><br><span class="line"><span class="comment">%测试 I_s = Ad^T_T(bs)I_bAd_T&#123;bs&#125; 将cm惯性矩阵转换到joint处</span></span><br><span class="line"><span class="comment">%&#123;</span></span><br><span class="line"><span class="comment">Mb = diag([172.27656, 172.27656, 172.27656, 3.16441, 32.90891, 34.31683]);</span></span><br><span class="line"><span class="comment">Rbs = [0.98655, 0.16044, 0.03136; 0.0005, 0.18889, -0.982; -0.16347, 0.9688, 0.18627];</span></span><br><span class="line"><span class="comment">Pbs = [0.74197; 0.019914; -0.013597];%Pbs = [0;0;0];%</span></span><br><span class="line"><span class="comment">Tbs = [Rbs, Pbs; 0 0 0 1];</span></span><br><span class="line"><span class="comment">Is = inertialmatirx_check(Tbs,Mb);</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line">Is =  Adjoint(T)'*Ib*Adjoint(T);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!-- <s>这里得到的Inertial Matrix不是[I_c ,0 ; 0 ,m]形的,目前我没找到相关的文献描述,但从推导来看,是没有问题的(加上惯性矩阵的转换,应该可以推导出下面两种方式等价).如果将对角置0,下述程序得不到相同的结果.</s> 纠正: 广义惯性矩阵 -->

<h5 id="center-of-mass"><a href="#center-of-mass" class="headerlink" title="center of mass"></a>center of mass</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%主要参数</span></span><br><span class="line"><span class="comment">%center of mass 相对位置</span></span><br><span class="line">M01 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.05</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M12 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.10</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M23 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.10</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M34 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.05</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">G = <span class="built_in">diag</span>(<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">6</span>)); <span class="comment">%inertia matrix</span></span><br><span class="line">w1 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">1</span>]; q1 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>]; q2 = [<span class="number">0.10</span>;<span class="number">0</span>;<span class="number">0</span>]; q3 = [<span class="number">0.20</span>;<span class="number">0</span>;<span class="number">0</span>];</span><br><span class="line">S = [[<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q1)], ...</span><br><span class="line">     [<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q2)], ...</span><br><span class="line">     [<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q3)]];</span><br></pre></td></tr></table></figure>

<!--  <s>我最初假设过长方体密度是1kg/m^3,但是惯性矩阵在matlab数量级在1e-5,太小了,导致结果与v-rep不一致,大概率是matlab舍入误差造成了,这一点可以加上format long试一下,记录完才想起来,就先留个位以后填吧.</s>

我又用single rb测试了一下(毕竟单个刚体的更简单,可以直接写出方程),应该是Vrep软件舍入误差问题,我已经去论坛反馈了.- - 等回头再看看.  

https://forum.coppeliarobotics.com/viewtopic.php?f=9&t=8356&p=32424#p32424 提完问我去逛了下手册,发现vrep里的 inertial matrix has divided by the mass. 所以是我MATLAB程序在计算cuboid惯性矩阵时除了问题,忘记给$I$部分乘上m了. 乌龙...
-->

<blockquote>
<p>当inertia 矩阵非常小时, 欧拉积分不太合适,容易积累误差.</p>
</blockquote>
<h5 id="joint-frame"><a href="#joint-frame" class="headerlink" title="joint frame"></a>joint frame</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%主要参数</span></span><br><span class="line"><span class="comment">%center of mass 相对位置</span></span><br><span class="line">M01 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.00</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M12 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.10</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M23 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.10</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">M34 = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0.10</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">G = <span class="built_in">diag</span>(<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">6</span>)); <span class="comment">%inertia matrix</span></span><br><span class="line">T = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">-0.05</span>]; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">Ic = inertialmatirx_check(T,G) <span class="comment">%转化为Ic标架下</span></span><br><span class="line">w1 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">1</span>]; q1 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>]; q2 = [<span class="number">0.10</span>;<span class="number">0</span>;<span class="number">0</span>]; q3 = [<span class="number">0.20</span>;<span class="number">0</span>;<span class="number">0</span>];</span><br><span class="line">S = [[<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q1)], ...</span><br><span class="line">     [<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q2)], ...</span><br><span class="line">     [<span class="number">0</span>; <span class="number">0</span>; <span class="number">1</span>;    -<span class="built_in">cross</span>(w1,q3)]];</span><br></pre></td></tr></table></figure>

<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><ul>
<li><p>Matlab<br><img src="testAnimated.gif" alt=""></p>
</li>
<li><p>V-rep<br><img src="vrep.gif" alt=""></p>
</li>
<li><p>对比.在Matlab中,步长取了50ms,与Vrep中一致,在仿真软件中选了最新的物理引擎.<br><img src="file.jpg" alt=""></p>
</li>
</ul>
<h5 id="下一步将继续研究离散的算法-待续"><a href="#下一步将继续研究离散的算法-待续" class="headerlink" title="下一步将继续研究离散的算法.(待续)"></a>下一步将继续研究离散的算法.(待续)</h5><hr>
<h4 id="附-V-rep基础教程"><a href="#附-V-rep基础教程" class="headerlink" title="附:V-rep基础教程"></a>附:V-rep基础教程</h4><p> 推荐阅读顺序如下:</p>
<ul>
<li><a href="https://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm" target="_blank" rel="noopener">Building a clean model tutorial</a> 从导入模型,建立关节开始大致熟悉一下流程,然后再用问题驱动,阅读User Manual最佳.</li>
<li><a href="https://www.coppeliarobotics.com/helpFiles/" target="_blank" rel="noopener">CoppeliaSim User Manual</a></li>
<li>最后,在Youtube有不少优秀的视频,例如<a href="https://www.youtube.com/watch?v=jfUA2W-niIc" target="_blank" rel="noopener">从CAD软件中导出Vrep读取的urdf文件并通过child Script控制</a><blockquote>
<p>这款仿真软件号称是机器人方面的瑞士军刀,在验证开发的算法以及可视化上很给力,并且可以通过API与Matlab通信,目前我只关注到这一层面,算法的研究上我还是用Matlab矩阵运算多一些,慢慢的结合V-rep做一些核对工作(<s>有时间有必要了解下它内部物理引擎所采取的算法,也先留个位吧</s>-.-)</p>
</blockquote>
</li>
</ul>
<h5 id="Bullet"><a href="#Bullet" class="headerlink" title="Bullet"></a>Bullet</h5><p>Bullet Physics is a professional <b>open source collision detection, rigid body and soft body dynamics<br>library</b>. The library is free for commercial use under the ZLib license. 在碰撞检测中用了GJK算法,室友以前还研究过,haha..巧的是,对于逆动力学算法,这个库采用的也是 Recursive Newton-Euler Algorithm (RNEA),而且<a href="https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=12437" target="_blank" rel="noopener">The computation of the joint space inertia (mass) matrix  is using the Composite Rigid Body Algorithm</a>.与我在上述实验中采用的算法一样,因为是开源的(它的积分策略为Symplectic Euler integrator),我们有必要也关注下它的<a href="https://github.com/erwincoumans/bullet3/tree/master/src/BulletInverseDynamics" target="_blank" rel="noopener">Github 仓库</a>.<!--MultiBodyTree::MultiBodyImpl::calculateMassMatrix --></p>
<ul>
<li><a href="http://www.cs.kent.edu/~ruttan/GameEngines/lectures/Bullet_User_Manual" target="_blank" rel="noopener">user_Manual</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>动力学</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>Matlab &amp; Vrep</tag>
      </tags>
  </entry>
  <entry>
    <title>读论文real time obstacle avoidance for manipulators and moile robots并仿真</title>
    <url>/posts/81ffa1cf/</url>
    <content><![CDATA[<h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><ul>
<li>精读论文并简单实现论文的例子</li>
<li>搭建一个基本的框架(包含正运动学,jacobian,正逆动力学部分),将其仿真实现,并可应用于n-dof的机械臂.</li>
</ul>
<p>仿真如下:(t=0.01,红色圆表示安全距离,蓝色圆为障碍.*点为目标点)<br><img src="artificial_potential.gif" alt=""></p>
<p>解决规划问题的论文有不少,但最经典的应该还是khatib1986那篇文章:real time obstacle avoidance for manipulators and moile robots.总的说来就是在operation space计算控制律,并通过jacobian矩阵将其转化为力矩,求得joint space的控制力作为控制信号.有陷入局部极小点的问题(这一块我将放在mathematica中进行分析,这款软件可视化很给力,尽管我还是个初学者)</p>
<h5 id="大体思路如下"><a href="#大体思路如下" class="headerlink" title="大体思路如下:"></a>大体思路如下:</h5><ol>
<li>寻找each arm segment距离障碍最近点,如果满足一定条件,则施加斥力</li>
<li>将斥力转化为关节力矩</li>
<li>作为控制律</li>
</ol>
<p>我们希望整个机械臂避免碰撞,但目前我们将问题减少至仅关心每段到障碍物最近的点.如果达到距离阀值则将施加斥力使其远离障碍.</p>
<p>为了找到手臂距离障碍物最近点$p_{psp}$,假设$x_c(:,i)$和$x_c(:,i+1)$为手臂(考虑直线)首尾端点.$ob_{orgin}$为障碍物中心.</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 计算各杆距离障碍物最近点closest,dist到障碍物中心距离,drhodx最近点指向障碍物外点向量</span></span><br><span class="line">taurep = <span class="built_in">zeros</span>(n,<span class="number">1</span>); <span class="comment">%斥力产生的力矩</span></span><br><span class="line">closest = []; dist = []; drhodx = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: n</span><br><span class="line">    vec_line = xc(:,<span class="built_in">i</span>+<span class="number">1</span>) - xc(:,<span class="built_in">i</span>);<span class="comment">%每一节端点</span></span><br><span class="line">    vec_ob_line = ob_orgin - xc(:,<span class="built_in">i</span>); <span class="comment">%the vector from the obstacle to the first line point</span></span><br><span class="line">    projection = <span class="built_in">dot</span>(vec_line,vec_ob_line)/<span class="built_in">dot</span>(vec_line,vec_line);</span><br><span class="line"><span class="keyword">if</span> projection  &lt; <span class="number">0</span></span><br><span class="line">    pclosest = xc(:,<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">elseif</span> projection &gt; <span class="number">1</span></span><br><span class="line">    pclosest = xc(:,<span class="built_in">i</span>+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    pclosest = xc(:,<span class="built_in">i</span>) + projection*vec_line;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">closest = [closest,pclosest]; <span class="comment">%ok</span></span><br></pre></td></tr></table></figure>
<p>利用夹角公式即可.<br>论文中<br>距离函数设计如下(arm closer,response stronger): </p>
<blockquote>
<p>$$F_{psp}=\eta(\frac{1}{\rho}-\frac{1}{\rho_0})\frac{1}{\rho^2}\frac{\partial \rho}{\partial x}$$<br>其中$\rho$表示到障碍的距离,$\rho_0$为安全(threshold)距离.(这里有个问题:如何合适的确定距离阀值呢?-这需要从论文的证明角度进行考虑.) </p>
</blockquote>
<hr>
<p>关键在于第二部分,我采用的是机械臂的几何雅克比矩阵[1] (spatial velocity twist jacobian,为方便表述记为$J_s$),故与论文中的$^0J$相差一个变换.</p>
<blockquote>
<p>几本教材的说法不太统一.</p>
</blockquote>
<p>为了计算受势场力点的jacobian矩阵,有三种方法,以三连杆为例. </p>
<p>第一种见:<a href="http://campus.unibo.it/218782/19/FIR_04_Kinem.pdf" target="_blank" rel="noopener">常见</a></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 方法1 求得world frame EE velocity jacobian</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: n</span><br><span class="line">    omg = p(:,n+<span class="number">1</span>)-p(:,<span class="built_in">i</span>);</span><br><span class="line">    matrix = [<span class="number">0</span>, -omg(<span class="number">3</span>), omg(<span class="number">2</span>); omg(<span class="number">3</span>), <span class="number">0</span>, -omg(<span class="number">1</span>); -omg(<span class="number">2</span>), omg(<span class="number">1</span>), <span class="number">0</span>];</span><br><span class="line">    js(<span class="number">4</span>:<span class="number">6</span>,<span class="built_in">i</span>) = -matrix*Slist(<span class="number">1</span>:<span class="number">3</span>,<span class="built_in">i</span>);</span><br><span class="line">    js(<span class="number">1</span>:<span class="number">3</span>,<span class="built_in">i</span>) = Slist(<span class="number">1</span>:<span class="number">3</span>,<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>第二种为数值计算:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%M为相对位姿&#123;psp&#125; in frame&#123;0&#125;</span><br><span class="line">epsilon &#x3D; 1e-3; </span><br><span class="line">epsilon_inv &#x3D; 1&#x2F;epsilon;</span><br><span class="line">n &#x3D; length(thetalist); % Dimension of the input x;</span><br><span class="line">ee &#x3D; fk(Slist,thetalist);</span><br><span class="line">f0 &#x3D; ee(1:3,4); </span><br><span class="line">% Do perturbation</span><br><span class="line">for i &#x3D; 1 : n</span><br><span class="line">    thetalist_ &#x3D; thetalist;</span><br><span class="line">    thetalist_(i) &#x3D;  thetalist(i) + epsilon;</span><br><span class="line">    ee_ &#x3D; fk(Slist,thetalist_);</span><br><span class="line">    jac(:, i) &#x3D; (ee_(1:3,4) - f0) .* epsilon_inv;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>第三种为[1] 书中所介绍的,利用伴随映射和Twist计算.不再赘述.</p>
<blockquote>
<p>再利用$\tau = J^TM_{x}F_{psp}$计算关节空间的力矩,方便起见,仿真程序设$M_{x}$为单位矩阵.($M$ works to linearize the control)</p>
</blockquote>
<hr>
<p>特别注意的是,虚拟引力的设计,为了使得追踪过程end-effector走直线(不受虚拟斥力时),考虑速度限制,详细见论文.</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">dx = js*dthetalist; </span><br><span class="line">lamb = kp/kv; vmax = <span class="number">2.5</span>; <span class="comment">%x_tilde = xc(:,end)-xd;</span></span><br><span class="line">dxd = lamb*(xd - xc(:,<span class="keyword">end</span>));v = vmax/(<span class="built_in">sqrt</span>(dxd'*dxd));</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">1</span></span><br><span class="line">    v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f_att = [<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);-kv*(dx(<span class="number">4</span>:<span class="number">6</span>,<span class="number">1</span>)-v*dxd)];</span><br></pre></td></tr></table></figure>

<p>关于动力学,采用递推公式(相比Lagrange方法,更适合多自由度情况),我将放在另一篇博客介绍.<a href="https://5imcs.com/posts/1e752288/">链接</a></p>
<p>[1]: A Mathematical Introduction to Robotic Manipulation</p>
]]></content>
      <categories>
        <category>trajectory planning</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>基于POE公式的机械臂正逆运动学仿真(Mathematica篇)</title>
    <url>/posts/f7cdd882/</url>
    <content><![CDATA[<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul>
<li>记录cad的一些基本操作,并且结合Mathematica进行仿真环境搭建.具体包括</li>
</ul>
<ol>
<li>装配机械臂</li>
<li>在仿真环境中导入机械臂三维模型,并且进行正逆运动学仿真.</li>
<li>分析经典数值算法计算效率,并思考一些可改进的方向.</li>
</ol>
<h4 id="移动蛇臂建模"><a href="#移动蛇臂建模" class="headerlink" title="移动蛇臂建模"></a>移动蛇臂建模</h4><h5 id="smiley-由FreeCAD进行零件装配并建立正逆运动学模型-2020年2-1-2-5日"><a href="#smiley-由FreeCAD进行零件装配并建立正逆运动学模型-2020年2-1-2-5日" class="headerlink" title=":smiley:由FreeCAD进行零件装配并建立正逆运动学模型(2020年2.1-2.5日)"></a>:smiley:由FreeCAD进行零件装配并建立正逆运动学模型(2020年2.1-2.5日)</h5><ul>
<li>考虑joint limit(仅考虑了Joint space-&gt;configuration space)</li>
</ul>
<p>仿真结果如下:</p>
<p><img src="exampleRobot_frame.gif" alt=""></p>
<p>相关参考文献:</p>
<ul>
<li><p>1.1995.a weighted least-norm solution based scheme for avoiding joint limits for redundant joint manipulators.IEEE trans on robotics and automation.</p>
</li>
<li><p>2.2018.[文件](A Weighted Gradient Projection Method for Inverse Kinematics of Redundant Manipulators Considering Multiple Performance Criteria.pdf) . </p>
</li>
</ul>
<blockquote>
<p>思路为对 $\dot{q}=J^{-1}\dot{x}$中 $J$ 施加权重. 缺点:WLN或WGP方法在某些情况下无解.</p>
</blockquote>
<h5 id="可改进的地方"><a href="#可改进的地方" class="headerlink" title="可改进的地方:"></a>可改进的地方:</h5><ul>
<li>从反应规划(避障)角度考虑joint limit问题</li>
<li>从连续的角度近似超冗余,提高计算效率</li>
</ul>
<blockquote>
<p>后续将整理freecad的基本操作,以及相关公式和mma代码.  仿真的想法来源于robinvista的<a href="https://blog.csdn.net/robinvista/article/details/70231205" target="_blank" rel="noopener" title="基于Mathematica的机器人仿真环境（机械臂篇）">博客文章</a></p>
</blockquote>
]]></content>
      <categories>
        <category>正逆运动学</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>Mathematica</tag>
      </tags>
  </entry>
</search>
