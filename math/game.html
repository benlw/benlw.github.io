<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ•°å­¦æ¶ˆæ¶ˆä¹ - å¿«ä¹ç®—æœ¯</title>
    <style>
        :root {
            --primary: #4A90E2;
            --accent: #FF6B6B;
            --bg: #F0F4F8;
            --cell-size: 45px;
            --gap: 5px;
        }

        body {
            font-family: 'Segoe UI', 'Rounded Mplus 1c', sans-serif;
            background-color: var(--bg);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        /* é¡¶éƒ¨é¢æ¿ - å±…ä¸­å¸ƒå±€ */
        header {
            width: 100%;
            padding: 10px 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            z-index: 100;
        }

        .btn-back {
            text-decoration: none;
            color: #888;
            font-size: 0.9rem;
            background: #f5f5f5;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: bold;
        }

        .stats {
            display: flex;
            gap: 25px;
            font-size: 1.2rem;
            font-weight: 800;
            color: #333;
            background: #eef2f7;
            padding: 8px 20px;
            border-radius: 20px;
        }

        .score-box { display: flex; align-items: center; gap: 5px; }
        .score-box span { color: var(--primary); font-size: 1.4rem; }
        .score-box.moves span { color: var(--accent); }

        /* æ¸¸æˆåŒºåŸŸ */
        #game-container {
            margin-top: 20px;
            background: #BBADA0;
            padding: var(--gap);
            border-radius: 12px;
            position: relative;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(7, var(--cell-size));
            grid-template-rows: repeat(8, var(--cell-size));
            gap: var(--gap);
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: rgba(238, 228, 218, 0.35);
            border-radius: 8px;
        }

        .tile {
            width: var(--cell-size);
            height: var(--cell-size);
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 26px;
            cursor: pointer;
            transition: transform 0.2s, top 0.3s ease-in, left 0.2s ease-in;
            z-index: 10;
            background: white;
            border-radius: 50%;
            box-shadow: inset 0 -4px 0 rgba(0,0,0,0.1), 0 3px 6px rgba(0,0,0,0.1);
        }

        .tile.selected {
            transform: scale(1.2);
            z-index: 20;
            box-shadow: 0 0 0 4px var(--primary);
        }

        .tile.matched {
            animation: popOut 0.3s forwards;
        }

        @keyframes popOut {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* é—®å·æ–¹å— */
        .tile[data-type="?"] {
            background: #FF6B6B;
            color: white;
            font-weight: bold;
            font-size: 30px;
            text-shadow: 1px 1px 0 #c0392b;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* å¼€å§‹/éš¾åº¦é€‰æ‹©ç•Œé¢ */
        .overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .overlay.hidden { display: none; }

        .start-title {
            font-size: 2.5rem;
            color: var(--primary);
            margin-bottom: 30px;
            text-shadow: 2px 2px 0 #ddd;
        }

        .level-btn {
            width: 200px;
            padding: 15px;
            margin: 10px;
            font-size: 1.2rem;
            border: none;
            border-radius: 25px;
            background: white;
            color: #555;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            font-weight: bold;
            border: 2px solid #eee;
        }

        .level-btn:active { transform: scale(0.95); }
        .level-btn.easy { border-color: #2ecc71; color: #2ecc71; }
        .level-btn.medium { border-color: #f1c40f; color: #f39c12; }
        .level-btn.hard { border-color: #e74c3c; color: #e74c3c; }

        /* ç­”é¢˜å¼¹çª— */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            backdrop-filter: blur(5px);
        }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }

        .math-modal {
            background: white;
            width: 85%;
            max-width: 340px;
            padding: 25px 20px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .modal-overlay.active .math-modal { transform: scale(1); }

        .equation { font-size: 3rem; font-weight: 900; color: var(--primary); margin: 10px 0 20px; }
        
        .answer-display {
            font-size: 2.2rem;
            height: 60px;
            line-height: 60px;
            border: 3px solid #eee;
            border-radius: 12px;
            margin-bottom: 20px;
            color: #333;
            font-weight: bold;
            background: #fafafa;
        }
        .answer-display.correct { color: #2ecc71; border-color: #2ecc71; background: #e8f8f5; }
        .answer-display.wrong { color: var(--accent); border-color: var(--accent); background: #fdedec; }

        .numpad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
        .num-btn {
            padding: 15px 0;
            font-size: 1.5rem;
            background: #f0f4f8;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 3px 0 #d1d9e6;
            color: #444;
            font-weight: bold;
        }
        .num-btn:active { transform: translateY(3px); box-shadow: none; }
        .num-btn.submit { background: var(--success); color: white; background: #2ecc71; box-shadow: 0 3px 0 #27ae60; grid-column: span 3; margin-top: 5px; }
        .num-btn.clear { background: #ffeaa7; color: #d35400; box-shadow: 0 3px 0 #fdcb6e; font-size: 1.2rem; }

        @media (max-width: 400px) {
            :root { --cell-size: 13vw; --gap: 4px; }
            .tile { font-size: 24px; }
            .stats { padding: 6px 15px; font-size: 1rem; }
            .score-box span { font-size: 1.2rem; }
        }
    </style>
</head>
<body>

<div class="overlay" id="startScreen">
    <div class="start-title">ğŸ“ æ•°å­¦æ¶ˆæ¶ˆä¹</div>
    <button class="level-btn easy" onclick="startGame(1)">â­ åˆçº§ (20ä»¥å†…)</button>
    <button class="level-btn medium" onclick="startGame(2)">â­â­ ä¸­çº§ (50ä»¥å†…)</button>
    <button class="level-btn hard" onclick="startGame(3)">ğŸ”¥ é«˜çº§ (ä¹˜æ³•)</button>
    <div style="margin-top: 30px; color: #888; font-size: 0.9rem;">ç‚¹å‡»é—®å·å›ç­”é—®é¢˜ï¼Œæ¶ˆé™¤æ•´è¡Œï¼</div>
</div>

<header>
    <a href="index.html" class="btn-back">ğŸ”™ è¿”å›è¯¾å ‚</a>
    <div class="stats">
        <div class="score-box">å¾—åˆ† <span id="score">0</span></div>
        <div class="score-box moves">æ­¥æ•° <span id="moves">20</span></div>
    </div>
</header>

<div id="game-container">
    <div id="grid"></div>
</div>

<div class="modal-overlay" id="mathModal">
    <div class="math-modal">
        <div style="color:#888; font-weight:bold; margin-bottom:5px;">ç­”å¯¹æ¶ˆé™¤æ•´è¡Œ!</div>
        <div class="equation" id="equation"></div>
        <div class="answer-display" id="userAnswer"></div>
        <div class="numpad" id="numpad">
            <button class="num-btn" data-val="1">1</button>
            <button class="num-btn" data-val="2">2</button>
            <button class="num-btn" data-val="3">3</button>
            <button class="num-btn" data-val="4">4</button>
            <button class="num-btn" data-val="5">5</button>
            <button class="num-btn" data-val="6">6</button>
            <button class="num-btn" data-val="7">7</button>
            <button class="num-btn" data-val="8">8</button>
            <button class="num-btn" data-val="9">9</button>
            <button class="num-btn clear" data-val="C">æ¸…ç©º</button>
            <button class="num-btn" data-val="0">0</button>
            <button class="num-btn" data-val="back">âŒ«</button>
            <button class="num-btn submit" data-val="OK">ç¡®å®š</button>
        </div>
    </div>
</div>

<script>
    // æ¸¸æˆé…ç½®
    const ROWS = 8;
    const COLS = 7;
    const TYPES = ['ğŸ', 'ğŸŠ', 'ğŸ‡', 'ğŸ¸', 'ğŸ¼', 'ğŸ¯'];
    const SPECIAL_TYPE = '?';
    const BOMB_TYPE = 'ğŸ’£';
    
    // çŠ¶æ€å˜é‡
    let grid = [];
    let score = 0;
    let moves = 20;
    let currentLevel = 1;
    let selectedTile = null;
    let isProcessing = false;
    let hasAnsweredRound = false; // æ ‡è®°å½“å‰å›åˆæ˜¯å¦å·²ç­”é¢˜
    
    // ç­”é¢˜çŠ¶æ€
    let currentMathAnswer = 0;
    let currentInput = "";
    let mathCallback = null;

    // DOMå…ƒç´ 
    const gridEl = document.getElementById('grid');
    const scoreEl = document.getElementById('score');
    const movesEl = document.getElementById('moves');
    const modal = document.getElementById('mathModal');
    const startScreen = document.getElementById('startScreen');

    function playSound(type) {
        const file = type === 'correct' ? 'bingo.mp3' : 'failure.mp3';
        new Audio(file).play().catch(() => {});
    }

    class Tile {
        constructor(r, c, type) {
            this.r = r;
            this.c = c;
            this.type = type;
            this.el = document.createElement('div');
            this.el.className = 'tile';
            this.el.textContent = type;
            this.el.dataset.type = type;
            
            // ç»‘å®šäº‹ä»¶
            this.el.addEventListener('mousedown', (e) => handleInputStart(this, e));
            this.el.addEventListener('touchstart', (e) => handleInputStart(this, e));
            
            gridEl.appendChild(this.el);
        }
    }

    function startGame(level) {
        currentLevel = level;
        startScreen.classList.add('hidden');
        initGame();
    }

    function initGame() {
        grid = [];
        gridEl.innerHTML = '';
        score = 0;
        moves = 20; // æ¯å±€20æ­¥
        scoreEl.textContent = score;
        movesEl.textContent = moves;

        // ç”ŸæˆèƒŒæ™¯æ ¼
        for(let i=0; i<ROWS*COLS; i++) {
            let bg = document.createElement('div');
            bg.className = 'cell';
            gridEl.appendChild(bg);
        }

        // å¡«å……åˆå§‹æ–¹å—
        for(let r=0; r<ROWS; r++) {
            let row = [];
            for(let c=0; c<COLS; c++) {
                // åˆå§‹ä¸ç”Ÿæˆé—®å·ï¼Œé˜²æ­¢å¼€å±€å¤ªä¹±
                let type = TYPES[Math.floor(Math.random() * TYPES.length)];
                let t = new Tile(r, c, type);
                row.push(t);
            }
            grid.push(row);
        }

        setTimeout(() => {
            refreshVisuals();
            checkMatchesAndRefill();
        }, 50);
    }

    function getRandomType() {
        // æé«˜æ¦‚ç‡åˆ° 25%
        if(Math.random() < 0.25) return SPECIAL_TYPE;
        // æå°æ¦‚ç‡ç›´æ¥æ‰è½ç‚¸å¼¹ (2%)
        if(Math.random() < 0.02) return BOMB_TYPE;
        return TYPES[Math.floor(Math.random() * TYPES.length)];
    }

    function refreshVisuals() {
        const cellW = gridEl.clientWidth / COLS;
        const cellH = gridEl.clientHeight / ROWS;
        
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(grid[r][c]) {
                    let tile = grid[r][c];
                    // è®¡ç®—ç»å¯¹ä½ç½®
                    tile.el.style.left = (c * cellW) + 'px';
                    tile.el.style.top = (r * cellH) + 'px';
                    tile.el.style.width = (cellW - 6) + 'px'; // å‡å»gapè°ƒæ•´
                    tile.el.style.height = (cellH - 6) + 'px';
                    // åŠ¨æ€è°ƒæ•´å­—ä½“
                    if(tile.type === '?') {
                         tile.el.style.fontSize = (cellW * 0.7) + 'px';
                    } else {
                         tile.el.style.fontSize = (cellW * 0.6) + 'px';
                    }
                }
            }
        }
    }

    function handleInputStart(tile, e) {
        if(isProcessing || moves <= 0) return;
        if (e.type === 'touchstart') e.preventDefault();

        if(!selectedTile) {
            selectedTile = tile;
            tile.el.classList.add('selected');
        } else {
            // å¦‚æœç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ª
            if(selectedTile === tile) {
                // ç‰¹æ®Šé€»è¾‘ï¼šå¦‚æœæ˜¯ç‚¸å¼¹ï¼Œå†æ¬¡ç‚¹å‡»åˆ™å¼•çˆ†
                if(tile.type === BOMB_TYPE) {
                    selectedTile.el.classList.remove('selected');
                    selectedTile = null;
                    explodeBomb(tile);
                    return;
                }
                
                // æ™®é€šæ–¹å—å–æ¶ˆé€‰ä¸­
                selectedTile.el.classList.remove('selected');
                selectedTile = null;
                return;
            }
            
            // æ£€æŸ¥ç›¸é‚»
            if (Math.abs(selectedTile.r - tile.r) + Math.abs(selectedTile.c - tile.c) === 1) {
                // æ–°çš„ä¸€æ­¥æ“ä½œå¼€å§‹ï¼Œé‡ç½®ç­”é¢˜æ ‡è®°
                hasAnsweredRound = false;
                swapTiles(selectedTile, tile);
            } else {
                // ä¸ç›¸é‚»ï¼Œæ”¹é€‰æ–°çš„
                selectedTile.el.classList.remove('selected');
                selectedTile = tile;
                tile.el.classList.add('selected');
            }
        }
    }

    async function swapTiles(t1, t2) {
        isProcessing = true;
        
        // äº¤æ¢é€»è¾‘ä½ç½®
        const r1 = t1.r, c1 = t1.c;
        const r2 = t2.r, c2 = t2.c;

        grid[r1][c1] = t2;
        grid[r2][c2] = t1;
        t1.r = r2; t1.c = c2;
        t2.r = r1; t2.c = c1;

        refreshVisuals();
        await wait(300);

        const matches = findMatches();
        if(matches.length > 0) {
            moves--;
            movesEl.textContent = moves;
            await processMatches(matches);
        } else {
            // è¿˜åŸ
            grid[r1][c1] = t1;
            grid[r2][c2] = t2;
            t1.r = r1; t1.c = c1;
            t2.r = r2; t2.c = c2;
            refreshVisuals();
            isProcessing = false;
        }
    }

    function findMatches() {
        let matches = new Set();
        
        // 1. æ¨ªå‘ä¸‰è¿
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS-2; c++) {
                let t1 = grid[r][c], t2 = grid[r][c+1], t3 = grid[r][c+2];
                if(t1 && t2 && t3 && t1.type === t2.type && t2.type === t3.type) {
                    matches.add(t1); matches.add(t2); matches.add(t3);
                }
            }
        }
        
        // 2. çºµå‘ä¸‰è¿
        for(let c=0; c<COLS; c++) {
            for(let r=0; r<ROWS-2; r++) {
                let t1 = grid[r][c], t2 = grid[r+1][c], t3 = grid[r+2][c];
                if(t1 && t2 && t3 && t1.type === t2.type && t2.type === t3.type) {
                    matches.add(t1); matches.add(t2); matches.add(t3);
                }
            }
        }

        // 3. ç”°å­—æ ¼ (2x2) æ¶ˆé™¤
        for(let r=0; r<ROWS-1; r++) {
            for(let c=0; c<COLS-1; c++) {
                let t1 = grid[r][c], t2 = grid[r][c+1];
                let t3 = grid[r+1][c], t4 = grid[r+1][c+1];
                
                if(t1 && t2 && t3 && t4 &&
                   t1.type === t2.type &&
                   t1.type === t3.type &&
                   t1.type === t4.type) {
                    matches.add(t1); matches.add(t2);
                    matches.add(t3); matches.add(t4);
                }
            }
        }

        return Array.from(matches);
    }

    async function processMatches(matches) {
        // åˆ†ç±»ï¼šé—®å·å’Œå…¶ä»–
        let questions = matches.filter(t => t.type === SPECIAL_TYPE);
        let others = matches.filter(t => t.type !== SPECIAL_TYPE);
        
        let transformToBomb = []; // éœ€è¦å˜æˆç‚¸å¼¹çš„tile

        if (questions.length > 0) {
            let shouldTransform = false;

            if (hasAnsweredRound) {
                // æœ¬å›åˆå·²ç»ç­”è¿‡é¢˜äº†ï¼Œç›´æ¥å¥–åŠ±
                shouldTransform = true;
            } else {
                // æ²¡ç­”è¿‡ï¼Œå¼¹çª—
                let correct = await promptMathQuestion();
                if (correct) {
                    hasAnsweredRound = true; // æ ‡è®°æœ¬å›åˆå·²ç­”
                    shouldTransform = true;
                    score += 200;
                } else {
                    // ç­”é”™ï¼Œå½“åšæ™®é€šæ¶ˆé™¤
                    others = matches; // å…¨éƒ¨æ¶ˆé™¤
                    questions = [];
                }
            }

            if (shouldTransform) {
                transformToBomb = questions;
            } else {
                // å¦‚æœå†³å®šä¸å˜æˆç‚¸å¼¹ï¼ˆæ¯”å¦‚ç­”é”™é€»è¾‘ï¼Œæˆ–è€…è®¾è®¡å˜æ›´ï¼‰ï¼Œé‚£å°±åŠ å›æ¶ˆé™¤åˆ—è¡¨
                // ä½†ä¸Šé¢é€»è¾‘æ˜¯ç­”é”™å°±å…¨æ¶ˆ
            }
        }

        // è§†è§‰æ¶ˆé™¤ (others)
        others.forEach(t => {
            t.el.classList.add('matched');
            score += 10;
        });
        
        // è§†è§‰å˜æ¢ (questions -> bomb)
        transformToBomb.forEach(t => {
            t.type = BOMB_TYPE;
            t.el.textContent = BOMB_TYPE;
            t.el.dataset.type = BOMB_TYPE;
            t.el.style.fontSize = '32px'; // ç‚¸å¼¹å¤§ä¸€ç‚¹
            t.el.classList.remove('selected'); // æ¸…é™¤é€‰ä¸­çŠ¶æ€
            
            // æ’­æ”¾ä¸€ä¸ªå˜æ¢ç‰¹æ•ˆï¼ˆç®€å•çš„ç¼©æ”¾ï¼‰
            t.el.style.transform = 'scale(1.3)';
            setTimeout(() => t.el.style.transform = 'scale(1)', 200);
        });

        scoreEl.textContent = score;
        await wait(300);

        // ç§»é™¤DOMå’Œæ•°æ® (åªç§»é™¤ others)
        others.forEach(t => {
            if(t.el.parentNode) t.el.parentNode.removeChild(t.el);
            grid[t.r][t.c] = null;
        });

        // ç‚¸å¼¹ç•™åœ¨åŸåœ°ï¼Œä¸éœ€è¦ç§»é™¤ï¼Œåªéœ€è¦æ›´æ–° grid çŠ¶æ€ï¼ˆå…¶å®å·²ç»æ”¹äº†typeï¼‰
        // ä½†ä¸ºäº†é˜²æ­¢é‡åŠ›ä¸‹è½æ—¶çš„bugï¼Œæˆ‘ä»¬ä¸éœ€è¦åšç‰¹æ®Šå¤„ç†ï¼Œ
        // å› ä¸º grid[r][c] è¿˜æ˜¯é‚£ä¸ª tile å¯¹è±¡ï¼Œåªæ˜¯ type å˜äº†ã€‚
        // applyGravity ä¼šæŠŠ null çš„å¡«æ»¡ã€‚

        await applyGravity();
    }

    async function explodeBomb(bombTile) {
        if (isProcessing) return;
        isProcessing = true;
        
        playSound('correct'); // æ’­æ”¾éŸ³æ•ˆ
        
        // åå­—æ¶ˆé™¤é€»è¾‘
        let toEliminate = new Set();
        toEliminate.add(bombTile);
        
        // è¡Œ
        for(let c=0; c<COLS; c++) {
            if(grid[bombTile.r][c]) toEliminate.add(grid[bombTile.r][c]);
        }
        // åˆ—
        for(let r=0; r<ROWS; r++) {
            if(grid[r][bombTile.c]) toEliminate.add(grid[r][bombTile.c]);
        }
        
        let list = Array.from(toEliminate);
        list.forEach(t => {
            t.el.classList.add('matched');
            score += 20; // ç‚¸å¼¹æ¶ˆé™¤åˆ†æ›´é«˜
        });
        scoreEl.textContent = score;
        
        // éœ‡åŠ¨å±å¹•æ•ˆæœ
        document.getElementById('game-container').style.transform = 'translate(2px, 2px)';
        setTimeout(() => document.getElementById('game-container').style.transform = 'translate(-2px, -2px)', 50);
        setTimeout(() => document.getElementById('game-container').style.transform = 'none', 100);

        await wait(300);
        
        list.forEach(t => {
            if(t.el.parentNode) t.el.parentNode.removeChild(t.el);
            grid[t.r][t.c] = null;
        });
        
        moves--; // å¼•çˆ†ç®—ä¸€æ­¥å—ï¼Ÿç®—å§
        movesEl.textContent = moves;

        await applyGravity();
    }

    async function applyGravity() {
        // ç»å…¸çš„ä¸‹è½ç®—æ³•
        for(let c=0; c<COLS; c++) {
            let emptyCount = 0;
            for(let r=ROWS-1; r>=0; r--) {
                if(grid[r][c] === null) {
                    emptyCount++;
                } else if(emptyCount > 0) {
                    let t = grid[r][c];
                    grid[r][c] = null;
                    grid[r + emptyCount][c] = t;
                    t.r = r + emptyCount;
                }
            }
            // é¡¶éƒ¨ç”Ÿæˆæ–°çš„
            for(let i=0; i<emptyCount; i++) {
                let r = emptyCount - 1 - i;
                let type = getRandomType();
                let t = new Tile(r, c, type);
                t.el.style.top = '-60px'; // ä»å±å¹•å¤–è½ä¸‹
                grid[r][c] = t;
            }
        }

        refreshVisuals();
        await wait(350);

        // è¿é”ååº”
        let newMatches = findMatches();
        if(newMatches.length > 0) {
            await processMatches(newMatches);
        } else {
            isProcessing = false;
        }
    }

    function checkMatchesAndRefill() {
        let matches = findMatches();
        if(matches.length > 0) processMatches(matches);
    }

    function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    // --- é¢˜ç›®ç”Ÿæˆé€»è¾‘ ---
    function generateProblem() {
        let n1, n2, op, ans;
        
        if (currentLevel === 1) { // 20ä»¥å†…åŠ å‡
            op = Math.random() > 0.5 ? '+' : '-';
            if (op === '+') {
                n1 = rand(1, 10); n2 = rand(1, 9);
                ans = n1 + n2;
            } else {
                n1 = rand(5, 19); n2 = rand(1, n1);
                ans = n1 - n2;
            }
        } else if (currentLevel === 2) { // 50ä»¥å†…åŠ å‡
            op = Math.random() > 0.5 ? '+' : '-';
            if (op === '+') {
                n1 = rand(10, 30); n2 = rand(5, 20);
                ans = n1 + n2;
            } else {
                n1 = rand(20, 50); n2 = rand(5, n1 - 5);
                ans = n1 - n2;
            }
        } else { // ä¹˜æ³•
            op = 'Ã—';
            n1 = rand(2, 9); n2 = rand(2, 9);
            ans = n1 * n2;
        }
        return { text: `${n1} ${op} ${n2} = ?`, ans: ans };
    }

    function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    function promptMathQuestion() {
        return new Promise((resolve) => {
            const prob = generateProblem();
            currentMathAnswer = prob.ans;
            
            document.getElementById('equation').textContent = prob.text;
            currentInput = "";
            updateInputDisplay();
            
            modal.classList.add('active');
            
            mathCallback = (success) => {
                modal.classList.remove('active');
                resolve(success);
            };
        });
    }

    function updateInputDisplay() {
        const disp = document.getElementById('userAnswer');
        disp.textContent = currentInput;
        disp.className = 'answer-display';
    }

    document.getElementById('numpad').addEventListener('click', (e) => {
        if(!modal.classList.contains('active')) return;
        const val = e.target.dataset.val;
        if(!val) return;

        if(val === 'C') {
            currentInput = "";
        } else if(val === 'back') {
            currentInput = currentInput.slice(0, -1);
        } else if(val === 'OK') {
            if(parseInt(currentInput) === currentMathAnswer) {
                playSound('correct');
                document.getElementById('userAnswer').classList.add('correct');
                setTimeout(() => mathCallback(true), 600);
            } else {
                playSound('wrong');
                document.getElementById('userAnswer').classList.add('wrong');
                setTimeout(() => mathCallback(false), 600);
            }
        } else {
            if(currentInput.length < 3) currentInput += val;
        }
        updateInputDisplay();
    });

    window.addEventListener('resize', () => { setTimeout(refreshVisuals, 100); });
</script>
</body>
</html>