<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ•°å­¦æ¶ˆæ¶ˆä¹ - å¿«ä¹ç®—æœ¯</title>
    <style>
        :root {
            --primary: #4A90E2;
            --accent: #FF6B6B;
            --bg: #F0F4F8;
            /* åŠ¨æ€è®¡ç®—æ ¼å­å¤§å°ï¼šå±å¹•å®½åº¦å‡å»è¾¹è·ï¼Œé™¤ä»¥7åˆ— */
            --cell-size: calc((min(100vw, 600px) - 30px) / 7);
            --gap: 6px;
        }

        body {
            font-family: 'Segoe UI', 'Rounded Mplus 1c', sans-serif;
            background-color: var(--bg);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        /* é¡¶éƒ¨é¢æ¿ - å±…ä¸­å¸ƒå±€ */
        header {
            width: 100%;
            padding: 10px 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            z-index: 100;
            flex-shrink: 0;
        }
        
        .high-score-label {
            font-size: 0.85rem;
            color: #888;
            font-weight: bold;
            margin-top: -3px;
        }

        .btn-back {
            text-decoration: none;
            color: #666;
            font-size: 0.9rem;
            background: #f0f0f0;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 1.1rem;
            font-weight: 800;
            color: #333;
            background: #eef2f7;
            padding: 8px 20px;
            border-radius: 20px;
        }

        .score-box { display: flex; align-items: center; gap: 6px; }
        .score-box span { color: var(--primary); font-size: 1.4rem; }
        .score-box.moves span { color: var(--accent); }

        /* æµ®åŠ¨æ–‡å­—ç‰¹æ•ˆ - å¼ºåŒ–ç‰ˆ */
        .float-text {
            position: absolute;
            font-size: 3.5rem;
            font-weight: 900;
            color: #ff9f43;
            /* æè¾¹æ•ˆæœ */
            -webkit-text-stroke: 2px #fff;
            text-shadow: 3px 3px 0px rgba(0,0,0,0.2);
            pointer-events: none;
            z-index: 300;
            white-space: nowrap;
            animation: popInStayOut 1.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes popInStayOut {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-15deg); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.2) rotate(5deg); opacity: 1; }
            40% { transform: translate(-50%, -50%) scale(1.0) rotate(0deg); opacity: 1; }
            80% { transform: translate(-50%, -100%) scale(1.1) rotate(0deg); opacity: 1; }
            100% { transform: translate(-50%, -150%) scale(0.5); opacity: 0; }
        }
        
        /* é“å…·æ ·å¼ */
        .tile[data-type="ğŸš€"] { background: #E0F7FA; font-size: 32px; animation: rocketPulse 1s infinite alternate; }
        .tile[data-type="ğŸŒŸ"] { background: #333; color: gold; font-size: 34px; animation: spin 3s linear infinite; box-shadow: 0 0 10px gold; }
        
        @keyframes rocketPulse { from { transform: scale(1); } to { transform: scale(1.1); } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        /* æ¸¸æˆåŒºåŸŸ */
        #game-container {
            margin-top: 20px;
            background: #BBADA0;
            padding: 10px;
            border-radius: 16px;
            position: relative;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
            /* å®½åº¦è‡ªé€‚åº” */
            width: min(96vw, 620px);
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(7, var(--cell-size));
            grid-template-rows: repeat(8, var(--cell-size));
            gap: var(--gap);
            /* ç¡®ä¿å±…ä¸­ */
            margin: 0 auto;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: rgba(238, 228, 218, 0.35);
            border-radius: 15%; /* åœ†è§’ç¨å¾®å¤§ä¸€ç‚¹ */
        }

        .tile {
            width: var(--cell-size);
            height: var(--cell-size);
            position: absolute;
            top: 0;
            left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            /* å­—ä½“å¤§å°æ ¹æ®æ ¼å­å¤§å°è‡ªé€‚åº” */
            font-size: calc(var(--cell-size) * 0.65);
            cursor: pointer;
            transition: transform 0.2s, top 0.2s ease-out, left 0.2s ease-out; /* åŠ¨ç”»åŠ å¿« */
            z-index: 10;
            background: white;
            border-radius: 50%; /* åœ†å½¢æ›´å¯çˆ± */
            box-shadow: inset 0 -4px 0 rgba(0,0,0,0.1), 0 3px 6px rgba(0,0,0,0.15);
        }

        .tile.selected {
            transform: scale(1.15);
            z-index: 20;
            box-shadow: 0 0 0 4px var(--primary);
            filter: brightness(1.1);
        }

        .tile.matched {
            animation: popOut 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes popOut {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.4); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        /* ç²’å­ç‰¹æ•ˆå®¹å™¨ */
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 100;
            border-radius: 50%;
            animation: particleFade 0.8s ease-out forwards;
        }
        
        @keyframes particleFade {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }

        /* ç‚¸å¼¹çˆ†ç‚¸æ³¢çº¹ */
        .shockwave {
            position: absolute;
            border-radius: 50%;
            border: 4px solid #FF6B6B;
            z-index: 50;
            transform: translate(-50%, -50%);
            animation: shockwaveAnim 0.6s ease-out forwards;
            pointer-events: none;
        }

        @keyframes shockwaveAnim {
            0% { width: 0; height: 0; opacity: 1; border-width: 10px; }
            100% { width: 600px; height: 600px; opacity: 0; border-width: 0; }
        }

        /* é—®å·æ–¹å— */
        .tile[data-type="?"] {
            background: #FF6B6B;
            color: white;
            font-weight: bold;
            font-size: 30px;
            text-shadow: 1px 1px 0 #c0392b;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* å¼€å§‹/éš¾åº¦é€‰æ‹©ç•Œé¢ */
        .overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .overlay.hidden { display: none; }

        .start-title {
            font-size: 2.5rem;
            color: var(--primary);
            margin-bottom: 30px;
            text-shadow: 2px 2px 0 #ddd;
        }

        .level-btn {
            width: 260px;
            padding: 15px;
            margin: 10px;
            font-size: 1.2rem;
            border: none;
            border-radius: 25px;
            background: white;
            color: #555;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            font-weight: bold;
            border: 2px solid #eee;
        }

        .level-btn:active { transform: scale(0.95); }
        .level-btn.easy { border-color: #2ecc71; color: #2ecc71; }
        .level-btn.medium { border-color: #f1c40f; color: #f39c12; }
        .level-btn.hard { border-color: #e74c3c; color: #e74c3c; }

        /* ç­”é¢˜å¼¹çª— */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            backdrop-filter: blur(5px);
        }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }

        .math-modal {
            background: white;
            width: 85%;
            max-width: 340px;
            padding: 25px 20px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .modal-overlay.active .math-modal { transform: scale(1); }

        .equation { font-size: 3rem; font-weight: 900; color: var(--primary); margin: 10px 0 20px; }
        
        .answer-display {
            font-size: 2.2rem;
            height: 60px;
            line-height: 60px;
            border: 3px solid #eee;
            border-radius: 12px;
            margin-bottom: 20px;
            color: #333;
            font-weight: bold;
            background: #fafafa;
        }
        .answer-display.correct { color: #2ecc71; border-color: #2ecc71; background: #e8f8f5; }
        .answer-display.wrong { color: var(--accent); border-color: var(--accent); background: #fdedec; }

        /* æ¸¸æˆç»“ç®—å¼¹çª— */
        .game-over-modal {
            background: white;
            width: 85%;
            max-width: 340px;
            padding: 30px 20px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.4);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .modal-overlay.active .game-over-modal { transform: scale(1); }
        
        .result-title { font-size: 2rem; color: #333; margin: 0 0 10px; }
        .result-score { font-size: 3rem; color: var(--primary); font-weight: 900; margin: 10px 0; }
        .result-stars { font-size: 2.5rem; margin: 15px 0 25px; letter-spacing: 5px; }
        .star.filled { color: #f1c40f; text-shadow: 0 2px 0 #d35400; }
        .star.empty { color: #e0e0e0; }
        
        .btn-restart {
            padding: 12px 30px;
            font-size: 1.2rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(74, 144, 226, 0.4);
            font-weight: bold;
        }
        .btn-restart:active { transform: scale(0.95); }

        .numpad { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
        .num-btn {
            padding: 15px 0;
            font-size: 1.5rem;
            background: #f0f4f8;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 3px 0 #d1d9e6;
            color: #444;
            font-weight: bold;
        }
        .num-btn:active { transform: translateY(3px); box-shadow: none; }
        .num-btn.submit { background: var(--success); color: white; background: #2ecc71; box-shadow: 0 3px 0 #27ae60; grid-column: span 3; margin-top: 5px; }
        .num-btn.clear { background: #ffeaa7; color: #d35400; box-shadow: 0 3px 0 #fdcb6e; font-size: 1.2rem; }

        @media (max-width: 400px) {
            :root { --cell-size: 13vw; --gap: 4px; }
            .tile { font-size: 24px; }
            .stats { padding: 6px 15px; font-size: 1rem; }
            .score-box span { font-size: 1.2rem; }
        }
    </style>
</head>
<body>

<div class="overlay" id="startScreen">
    <div class="start-title">ğŸ“ æ•°å­¦æ¶ˆæ¶ˆä¹</div>
    <button class="level-btn easy" onclick="startGame(1)">â­ åˆçº§ (20ä»¥å†…)</button>
    <button class="level-btn medium" onclick="startGame(2)">â­â­ ä¸­çº§ (50ä»¥å†…)</button>
    <button class="level-btn hard" onclick="startGame(3)">ğŸ”¥ é«˜çº§ (ä¹˜æ³•)</button>
    <div style="margin-top: 30px; color: #888; font-size: 0.9rem;">ç‚¹å‡»é—®å·å›ç­”é—®é¢˜ï¼Œæ¶ˆé™¤æ•´è¡Œï¼</div>
</div>

<header>
    <a href="index.html" class="btn-back">ğŸ”™ è¿”å›è¯¾å ‚</a>
    <div class="high-score-label">æœ€é«˜åˆ†: <span id="highScore">0</span></div>
    <div class="stats">
        <div class="score-box">å¾—åˆ† <span id="score">0</span></div>
        <div class="score-box moves">æ­¥æ•° <span id="moves">20</span></div>
    </div>
</header>

<div id="game-container">
    <div id="grid"></div>
</div>

<!-- æ¸¸æˆç»“æŸå¼¹çª— -->
<div class="modal-overlay" id="gameOverModal">
    <div class="game-over-modal">
        <h2 class="result-title" id="endTitle">æ¸¸æˆç»“æŸ</h2>
        <div class="result-score" id="endScore">0</div>
        <div class="result-stars" id="endStars">
            <span class="star empty">â˜…</span><span class="star empty">â˜…</span><span class="star empty">â˜…</span>
        </div>
        <button class="btn-restart" onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
    </div>
</div>

<div class="modal-overlay" id="mathModal">
    <div class="math-modal">
        <div style="color:#888; font-weight:bold; margin-bottom:5px;">ç­”å¯¹æ¶ˆé™¤æ•´è¡Œ!</div>
        <div class="equation" id="equation"></div>
        <div class="answer-display" id="userAnswer"></div>
        <div class="numpad" id="numpad">
            <button class="num-btn" data-val="1">1</button>
            <button class="num-btn" data-val="2">2</button>
            <button class="num-btn" data-val="3">3</button>
            <button class="num-btn" data-val="4">4</button>
            <button class="num-btn" data-val="5">5</button>
            <button class="num-btn" data-val="6">6</button>
            <button class="num-btn" data-val="7">7</button>
            <button class="num-btn" data-val="8">8</button>
            <button class="num-btn" data-val="9">9</button>
            <button class="num-btn clear" data-val="C">æ¸…ç©º</button>
            <button class="num-btn" data-val="0">0</button>
            <button class="num-btn" data-val="back">âŒ«</button>
            <button class="num-btn submit" data-val="OK">ç¡®å®š</button>
        </div>
    </div>
</div>

<script>
    // æ¸¸æˆé…ç½®
    const ROWS = 8;
    const COLS = 7;
    const TYPES = ['ğŸ', 'ğŸŠ', 'ğŸ‡', 'ğŸ¸', 'ğŸ¼', 'ğŸ¯'];
    const SPECIAL_TYPE = '?';
    const BOMB_TYPE = 'ğŸ’£';
    const ROCKET_TYPE = 'ğŸš€';
    const STAR_TYPE = 'ğŸŒŸ';
    
    // çŠ¶æ€å˜é‡
    let grid = [];
    let score = 0;
    let moves = 20;
    let currentLevel = 1;
    let selectedTile = null;
    let isProcessing = false;
    let hasAnsweredRound = false; // æ ‡è®°å½“å‰å›åˆæ˜¯å¦å·²ç­”é¢˜
    let comboCount = 0; // è¿å‡»è®¡æ•°
    
    // ç­”é¢˜çŠ¶æ€
    let currentMathAnswer = 0;
    let currentInput = "";
    let mathCallback = null;

    // DOMå…ƒç´ 
    const gridEl = document.getElementById('grid');
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const movesEl = document.getElementById('moves');
    const modal = document.getElementById('mathModal');
    const gameOverModal = document.getElementById('gameOverModal');
    const startScreen = document.getElementById('startScreen');

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playSound(type) {
        if (type === 'explode') {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const t = audioCtx.currentTime;
            
            // 1. åˆ¶é€ å™ªéŸ³ (çˆ†ç‚¸å£°æ ¸å¿ƒ)
            const bufferSize = audioCtx.sampleRate * 0.5; // 0.5ç§’
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            
            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(800, t);
            noiseFilter.frequency.exponentialRampToValueAtTime(50, t + 0.4);
            
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.8, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
            
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noise.start();
            return;
        }

        const file = type === 'correct' ? 'bingo.mp3' : 'failure.mp3';
        new Audio(file).play().catch(() => {});
    }

    // è¾“å…¥å¤„ç†å˜é‡
    let startX = 0;
    let startY = 0;
    let activeTile = null;

    class Tile {
        constructor(r, c, type) {
            this.r = r;
            this.c = c;
            this.type = type;
            this.el = document.createElement('div');
            this.el.className = 'tile';
            this.el.textContent = type;
            this.el.dataset.type = type;
            
            // ç»‘å®šç»Ÿä¸€çš„è§¦æ‘¸/é¼ æ ‡äº‹ä»¶
            this.bindEvents();
            
            gridEl.appendChild(this.el);
        }

        bindEvents() {
            const startHandler = (e) => {
                if(isProcessing || moves <= 0) return;
                
                const touch = e.touches ? e.touches[0] : e;
                startX = touch.clientX;
                startY = touch.clientY;
                activeTile = this;
            };

            const endHandler = (e) => {
                if(!activeTile || isProcessing || moves <= 0) return;
                
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                const endX = touch.clientX;
                const endY = touch.clientY;
                
                const diffX = endX - startX;
                const diffY = endY - startY;
                
                const threshold = 30; // æ»‘åŠ¨é˜ˆå€¼
                
                // 1. åˆ¤å®šä¸ºæ»‘åŠ¨ (Drag)
                if (Math.abs(diffX) > threshold || Math.abs(diffY) > threshold) {
                    let targetR = activeTile.r;
                    let targetC = activeTile.c;
                    
                    if (Math.abs(diffX) > Math.abs(diffY)) {
                        // æ¨ªå‘
                        if (diffX > 0) targetC++; else targetC--;
                    } else {
                        // çºµå‘
                        if (diffY > 0) targetR++; else targetR--;
                    }
                    
                    // è¾¹ç•Œæ£€æŸ¥
                    if (targetR >= 0 && targetR < ROWS && targetC >= 0 && targetC < COLS) {
                        const targetTile = grid[targetR][targetC];
                        if (targetTile) {
                            hasAnsweredRound = false;
                            // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€ï¼ˆå¦‚æœæœ‰ï¼‰
                            if(selectedTile) {
                                selectedTile.el.classList.remove('selected');
                                selectedTile = null;
                            }
                            swapTiles(activeTile, targetTile);
                        }
                    }
                } 
                // 2. åˆ¤å®šä¸ºç‚¹å‡» (Tap)
                else {
                    handleTap(activeTile);
                }
                
                activeTile = null;
            };

            this.el.addEventListener('mousedown', startHandler);
            this.el.addEventListener('touchstart', startHandler, {passive: false});
            
            this.el.addEventListener('mouseup', endHandler);
            this.el.addEventListener('touchend', endHandler);
        }
    }

    function handleTap(tile) {
        if(!selectedTile) {
            selectedTile = tile;
            tile.el.classList.add('selected');
        } else {
            // å¦‚æœç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ª
            if(selectedTile === tile) {
                // ç‰¹æ®Šé€»è¾‘ï¼šå¦‚æœæ˜¯ç‚¸å¼¹ï¼Œå†æ¬¡ç‚¹å‡»åˆ™å¼•çˆ†
                if(tile.type === BOMB_TYPE) {
                    selectedTile.el.classList.remove('selected');
                    selectedTile = null;
                    explodeBomb(tile);
                    return;
                }
                // æ™®é€šæ–¹å—å–æ¶ˆé€‰ä¸­
                selectedTile.el.classList.remove('selected');
                selectedTile = null;
            } else {
                // ç‚¹å‡»äº†å¦ä¸€ä¸ª
                // æ£€æŸ¥æ˜¯å¦ç›¸é‚»ï¼Œç›¸é‚»åˆ™äº¤æ¢ï¼ˆå…¼å®¹ç‚¹å‡»å¼ç©æ³•ï¼‰
                if (Math.abs(selectedTile.r - tile.r) + Math.abs(selectedTile.c - tile.c) === 1) {
                    hasAnsweredRound = false;
                    selectedTile.el.classList.remove('selected');
                    swapTiles(selectedTile, tile);
                    selectedTile = null;
                } else {
                    // ä¸ç›¸é‚»ï¼Œæ”¹é€‰æ–°çš„
                    selectedTile.el.classList.remove('selected');
                    selectedTile = tile;
                    tile.el.classList.add('selected');
                }
            }
        }
    }

    function createParticles(x, y, color, count=8, scale=1) {
        for(let i=0; i<count; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            const bg = color || (['#FF6B6B', '#4A90E2', '#F1C40F', '#2ECC71'][Math.floor(Math.random()*4)]);
            p.style.background = bg;
            const size = (Math.random() * 10 + 5) * scale;
            p.style.width = size + 'px';
            p.style.height = size + 'px';
            p.style.left = x + 'px';
            p.style.top = y + 'px';
            const angle = Math.random() * Math.PI * 2;
            const velocity = (Math.random() * 80 + 40) * scale;
            const tx = Math.cos(angle) * velocity + 'px';
            const ty = Math.sin(angle) * velocity + 'px';
            p.style.setProperty('--tx', tx);
            p.style.setProperty('--ty', ty);
            document.body.appendChild(p);
            setTimeout(() => p.remove(), 800);
        }
    }

    function showFloatText(text, x, y) {
        const el = document.createElement('div');
        el.className = 'float-text';
        el.textContent = text;
        
        // éšæœºé¢œè‰²
        const colors = ['#FF6B6B', '#4ECDC4', '#FFE66D', '#FF9F43', '#A8D8EA'];
        el.style.color = colors[Math.floor(Math.random() * colors.length)];
        
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1600); // å»¶é•¿ç§»é™¤æ—¶é—´
    }

    function startGame(level) {
        currentLevel = level;
        startScreen.classList.add('hidden');
        updateHighScoreDisplay();
        initGame();
    }

    function initGame() {
        grid = [];
        gridEl.innerHTML = '';
        score = 0;
        moves = 20; // æ¯å±€20æ­¥
        scoreEl.textContent = score;
        movesEl.textContent = moves;
        comboCount = 0;

        // ç”ŸæˆèƒŒæ™¯æ ¼
        for(let i=0; i<ROWS*COLS; i++) {
            let bg = document.createElement('div');
            bg.className = 'cell';
            gridEl.appendChild(bg);
        }

        // å¡«å……åˆå§‹æ–¹å—
        for(let r=0; r<ROWS; r++) {
            let row = [];
            for(let c=0; c<COLS; c++) {
                // åˆå§‹ä¸ç”Ÿæˆé—®å·ï¼Œé˜²æ­¢å¼€å±€å¤ªä¹±
                let type = TYPES[Math.floor(Math.random() * TYPES.length)];
                let t = new Tile(r, c, type);
                row.push(t);
            }
            grid.push(row);
        }

        setTimeout(() => {
            refreshVisuals();
            checkMatchesAndRefill();
        }, 50);
    }

    function checkGameOver() {
        if (moves <= 0 && !isProcessing) {
            const key = `math_crush_level_${currentLevel}_high`;
            const currentHigh = parseInt(localStorage.getItem(key) || '0');
            if (score > currentHigh) {
                localStorage.setItem(key, score);
            }
            setTimeout(() => {
                showGameOver();
            }, 800);
            return true;
        }
        return false;
    }

    function showGameOver() {
        gameOverModal.classList.add('active');
        document.getElementById('endScore').textContent = score;
        
        let stars = 1;
        if (score > 1000) stars = 2;
        if (score > 2500) stars = 3;
        
        let starsHtml = '';
        for(let i=0; i<3; i++) {
            starsHtml += `<span class="star ${i < stars ? 'filled' : 'empty'}">â˜…</span>`;
        }
        document.getElementById('endStars').innerHTML = starsHtml;
        
        let titles = ['ç»§ç»­åŠ æ²¹!', 'ä¸é”™å“¦!', 'å¤ªæ£’äº†!'];
        document.getElementById('endTitle').textContent = titles[stars-1];
        
        playSound('correct');
    }

    function updateHighScoreDisplay() {
        const key = `math_crush_level_${currentLevel}_high`;
        highScoreEl.textContent = localStorage.getItem(key) || '0';
    }

    function getRandomType() {
        // æé«˜æ¦‚ç‡åˆ° 25%
        if(Math.random() < 0.25) return SPECIAL_TYPE;
        // æå°æ¦‚ç‡ç›´æ¥æ‰è½ç‚¸å¼¹ (2%)
        if(Math.random() < 0.02) return BOMB_TYPE;
        return TYPES[Math.floor(Math.random() * TYPES.length)];
    }

    function refreshVisuals() {
        // æ›´ç¨³å¥çš„æ–¹æ³•ï¼šç›´æ¥è¯»å–å¯¹åº”æ ¼å­çš„ä½ç½®
        const cells = document.querySelectorAll('.cell');
        
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(grid[r][c]) {
                    let tile = grid[r][c];
                    let cellIndex = r * COLS + c;
                    let cell = cells[cellIndex];
                    
                    if(cell) {
                        // ç›¸å¯¹äº #grid çš„ä½ç½®
                        tile.el.style.left = cell.offsetLeft + 'px';
                        tile.el.style.top = cell.offsetTop + 'px';
                        tile.el.style.width = cell.offsetWidth + 'px';
                        tile.el.style.height = cell.offsetHeight + 'px';
                        
                        // å­—ä½“è°ƒæ•´
                        let fontSize = cell.offsetWidth * 0.65;
                        if(tile.type === BOMB_TYPE) fontSize = cell.offsetWidth * 0.75;
                        tile.el.style.fontSize = fontSize + 'px';
                    }
                }
            }
        }
    }

    async function swapTiles(t1, t2) {
        isProcessing = true;
        comboCount = 0; // æ–°çš„ä¸€æ­¥ï¼Œé‡ç½®è¿å‡»
        
        // äº¤æ¢é€»è¾‘ä½ç½®
        const r1 = t1.r, c1 = t1.c;
        const r2 = t2.r, c2 = t2.c;

        grid[r1][c1] = t2;
        grid[r2][c2] = t1;
        t1.r = r2; t1.c = c2;
        t2.r = r1; t2.c = c1;

        refreshVisuals();
        await wait(300);

        const matches = findMatches();
        if(matches.length > 0) {
            moves--;
            movesEl.textContent = moves;
            await processMatches(matches);
        } else {
            // è¿˜åŸ
            grid[r1][c1] = t1;
            grid[r2][c2] = t2;
            t1.r = r1; t1.c = c1;
            t2.r = r2; t2.c = c2;
            refreshVisuals();
            isProcessing = false;
        }
    }

    function findMatches() {
        let matches = new Set();
        
        // 1. æ¨ªå‘ä¸‰è¿
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS-2; c++) {
                let t1 = grid[r][c], t2 = grid[r][c+1], t3 = grid[r][c+2];
                if(t1 && t2 && t3 && 
                   t1.type !== BOMB_TYPE && 
                   t1.type === t2.type && t2.type === t3.type) {
                    matches.add(t1); matches.add(t2); matches.add(t3);
                }
            }
        }
        
        // 2. çºµå‘ä¸‰è¿
        for(let c=0; c<COLS; c++) {
            for(let r=0; r<ROWS-2; r++) {
                let t1 = grid[r][c], t2 = grid[r+1][c], t3 = grid[r+2][c];
                if(t1 && t2 && t3 && 
                   t1.type !== BOMB_TYPE &&
                   t1.type === t2.type && t2.type === t3.type) {
                    matches.add(t1); matches.add(t2); matches.add(t3);
                }
            }
        }

        // 3. ç”°å­—æ ¼ (2x2) æ¶ˆé™¤
        for(let r=0; r<ROWS-1; r++) {
            for(let c=0; c<COLS-1; c++) {
                let t1 = grid[r][c], t2 = grid[r][c+1];
                let t3 = grid[r+1][c], t4 = grid[r+1][c+1];
                
                if(t1 && t2 && t3 && t4 &&
                   t1.type !== BOMB_TYPE &&
                   t1.type === t2.type &&
                   t1.type === t3.type &&
                   t1.type === t4.type) {
                    matches.add(t1); matches.add(t2);
                    matches.add(t3); matches.add(t4);
                }
            }
        }

        return Array.from(matches);
    }

    async function processMatches(matches) {
        comboCount++;
        // æ˜¾ç¤º Combo æ–‡å­—
        if (comboCount > 1) {
            const rect = document.getElementById('game-container').getBoundingClientRect();
            const text = ['Good!', 'Great!', 'Amazing!', 'Unbelievable!'][Math.min(comboCount-2, 3)];
            showFloatText(text + ` x${comboCount}`, rect.width/2 + rect.left, rect.height/2 + rect.top);
            
            score += comboCount * 50; // è¿å‡»åŠ åˆ†
        }

        // åˆ†ç±»ï¼šé—®å·å’Œå…¶ä»–
        let questions = matches.filter(t => t.type === SPECIAL_TYPE);
        let others = matches.filter(t => t.type !== SPECIAL_TYPE);
        
        let transformToBomb = []; // éœ€è¦å˜æˆç‚¸å¼¹çš„tile
        let keepOnGrid = []; // éœ€è¦ç•™åœ¨åœºä¸Šçš„tile

        if (questions.length > 0) {
            let shouldTransform = false;

            if (hasAnsweredRound) {
                // æœ¬å›åˆå·²ç»ç­”è¿‡é¢˜äº†ï¼Œç›´æ¥å¥–åŠ±
                shouldTransform = true;
            } else {
                // æ²¡ç­”è¿‡ï¼Œå¼¹çª—
                let correct = await promptMathQuestion();
                if (correct) {
                    hasAnsweredRound = true; // æ ‡è®°æœ¬å›åˆå·²ç­”
                    shouldTransform = true;
                    score += 200;
                } else {
                    // ç­”é”™ï¼Œé—®å·å½“åšæ™®é€šæ¶ˆé™¤ï¼ŒåŠ å…¥ others
                    others = others.concat(questions);
                    questions = [];
                }
            }

            if (shouldTransform) {
                // åªç”Ÿæˆä¸€ä¸ªç‚¸å¼¹ (å–å…¶ä¸­ä¸€ä¸ª)
                transformToBomb = [questions[0]];
                // å‰©ä¸‹çš„é—®å·ä½œä¸ºæ™®é€šæ¶ˆé™¤
                others = others.concat(questions.slice(1));
            }
        }

        // è§†è§‰æ¶ˆé™¤ (others)
        others.forEach(t => {
            t.el.classList.add('matched');
            score += 10;
            
            // ç²’å­ç‰¹æ•ˆ
            const rect = t.el.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            createParticles(centerX, centerY, null, 6);
        });
        
        // è§†è§‰å˜æ¢ (questions -> bomb)
        transformToBomb.forEach(t => {
            t.type = BOMB_TYPE;
            t.el.textContent = BOMB_TYPE;
            t.el.dataset.type = BOMB_TYPE;
            // æ ·å¼é‡ç½®
            t.el.classList.remove('selected');
            t.el.classList.remove('matched'); // é˜²æ­¢ä¹‹å‰çš„åŠ¨ç”»å¹²æ‰°
            t.el.style.opacity = '1';
            t.el.style.transform = 'scale(1)';
            
            // æ’­æ”¾ä¸€ä¸ªå˜æ¢ç‰¹æ•ˆï¼ˆç®€å•çš„ç¼©æ”¾ï¼‰
            // éœ€è¦å¼ºåˆ¶é‡ç»˜ä¸€ä¸‹æˆ–è€…å»¶æ—¶
            setTimeout(() => {
                t.el.style.transform = 'scale(1.4)';
                setTimeout(() => t.el.style.transform = 'scale(1)', 200);
            }, 50);
            
            // å˜èº«ç²’å­ç‰¹æ•ˆ
            const rect = t.el.getBoundingClientRect();
            createParticles(rect.left + rect.width/2, rect.top + rect.height/2, '#333', 12, 1.2);
        });

        scoreEl.textContent = score;
        await wait(300);

        // ç§»é™¤DOMå’Œæ•°æ® (åªç§»é™¤ others)
        others.forEach(t => {
            if(t.el.parentNode) t.el.parentNode.removeChild(t.el);
            grid[t.r][t.c] = null;
        });

        await applyGravity();
    }

    async function explodeBomb(bombTile) {
        if (isProcessing) return;
        isProcessing = true;
        comboCount++; 

        playSound('explode'); // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
        
        // 1. åˆ›å»ºå·¨å¤§éœ‡æ³¢
        const rect = bombTile.el.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const wave = document.createElement('div');
        wave.className = 'shockwave';
        wave.style.left = centerX + 'px';
        wave.style.top = centerY + 'px';
        document.body.appendChild(wave);
        setTimeout(() => wave.remove(), 600);
        
        // 2. çˆ†ç‚¸ç«èŠ±
        createParticles(centerX, centerY, '#FF4500', 30, 2.0);

        // åŒºåŸŸæ¶ˆé™¤é€»è¾‘ (5x5 è¶…çº§çˆ†ç‚¸)
        let toEliminate = new Set();
        
        // èŒƒå›´æ‰©å¤§åˆ°åŠå¾„2 (å³ 5x5)
        for(let r = bombTile.r - 2; r <= bombTile.r + 2; r++) {
            for(let c = bombTile.c - 2; c <= bombTile.c + 2; c++) {
                if(r >= 0 && r < ROWS && c >= 0 && c < COLS && grid[r][c]) {
                    toEliminate.add(grid[r][c]);
                }
            }
        }
        
        let list = Array.from(toEliminate);
        list.forEach(t => {
            t.el.classList.add('matched');
            score += 20; // ç‚¸å¼¹æ¶ˆé™¤åˆ†æ›´é«˜
            
            // è¢«ç‚¸æ‰çš„æ–¹å—ä¹Ÿæœ‰å°çˆ†ç‚¸
            const r = t.el.getBoundingClientRect();
            createParticles(r.left + r.width/2, r.top + r.height/2, '#FF6B6B', 4);
        });
        scoreEl.textContent = score;
        
        // éœ‡åŠ¨å±å¹•æ•ˆæœ
        document.getElementById('game-container').style.transition = 'transform 0.05s';
        document.getElementById('game-container').style.transform = 'translate(5px, 5px) rotate(1deg)';
        setTimeout(() => document.getElementById('game-container').style.transform = 'translate(-5px, -5px) rotate(-1deg)', 50);
        setTimeout(() => document.getElementById('game-container').style.transform = 'translate(3px, -3px)', 100);
        setTimeout(() => document.getElementById('game-container').style.transform = 'none', 150);

        await wait(400); // ç­‰ä¹…ä¸€ç‚¹çœ‹ç‰¹æ•ˆ
        
        list.forEach(t => {
            if(t.el.parentNode) t.el.parentNode.removeChild(t.el);
            grid[t.r][t.c] = null;
        });
        
        moves--; 
        movesEl.textContent = moves;

        await applyGravity();
    }

    async function applyGravity() {
        // ç»å…¸çš„ä¸‹è½ç®—æ³•
        for(let c=0; c<COLS; c++) {
            let emptyCount = 0;
            for(let r=ROWS-1; r>=0; r--) {
                if(grid[r][c] === null) {
                    emptyCount++;
                } else if(emptyCount > 0) {
                    let t = grid[r][c];
                    grid[r][c] = null;
                    grid[r + emptyCount][c] = t;
                    t.r = r + emptyCount;
                }
            }
            // é¡¶éƒ¨ç”Ÿæˆæ–°çš„
            for(let i=0; i<emptyCount; i++) {
                let r = emptyCount - 1 - i;
                let type = getRandomType();
                let t = new Tile(r, c, type);
                t.el.style.top = '-60px'; // ä»å±å¹•å¤–è½ä¸‹
                grid[r][c] = t;
            }
        }

        refreshVisuals();
        await wait(350);

        // è¿é”ååº”
        let newMatches = findMatches();
        if(newMatches.length > 0) {
            await processMatches(newMatches);
        } else {
            isProcessing = false;
            checkGameOver();
        }
    }

    function checkMatchesAndRefill() {
        let matches = findMatches();
        if(matches.length > 0) processMatches(matches);
    }

    function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

    // --- é¢˜ç›®ç”Ÿæˆé€»è¾‘ ---
    function generateProblem() {
        let n1, n2, op, ans;
        
        if (currentLevel === 1) { // 20ä»¥å†…åŠ å‡
            op = Math.random() > 0.5 ? '+' : '-';
            if (op === '+') {
                n1 = rand(1, 10); n2 = rand(1, 9);
                ans = n1 + n2;
            } else {
                n1 = rand(5, 19); n2 = rand(1, n1);
                ans = n1 - n2;
            }
        } else if (currentLevel === 2) { // 50ä»¥å†…åŠ å‡
            op = Math.random() > 0.5 ? '+' : '-';
            if (op === '+') {
                n1 = rand(10, 30); n2 = rand(5, 20);
                ans = n1 + n2;
            } else {
                n1 = rand(20, 50); n2 = rand(5, n1 - 5);
                ans = n1 - n2;
            }
        } else { // ä¹˜æ³•
            op = 'Ã—';
            n1 = rand(2, 9); n2 = rand(2, 9);
            ans = n1 * n2;
        }
        return { text: `${n1} ${op} ${n2} = ?`, ans: ans };
    }

    function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    function promptMathQuestion() {
        return new Promise((resolve) => {
            const prob = generateProblem();
            currentMathAnswer = prob.ans;
            
            document.getElementById('equation').textContent = prob.text;
            currentInput = "";
            updateInputDisplay();
            
            modal.classList.add('active');
            
            mathCallback = (success) => {
                modal.classList.remove('active');
                resolve(success);
            };
        });
    }

    function updateInputDisplay() {
        const disp = document.getElementById('userAnswer');
        disp.textContent = currentInput;
        disp.className = 'answer-display';
    }

    document.getElementById('numpad').addEventListener('click', (e) => {
        if(!modal.classList.contains('active')) return;
        const val = e.target.dataset.val;
        if(!val) return;

        if(val === 'C') {
            currentInput = "";
        } else if(val === 'back') {
            currentInput = currentInput.slice(0, -1);
        } else if(val === 'OK') {
            if(parseInt(currentInput) === currentMathAnswer) {
                playSound('correct');
                document.getElementById('userAnswer').classList.add('correct');
                setTimeout(() => mathCallback(true), 600);
            } else {
                playSound('wrong');
                document.getElementById('userAnswer').classList.add('wrong');
                setTimeout(() => mathCallback(false), 600);
            }
        } else {
            if(currentInput.length < 3) currentInput += val;
        }
        updateInputDisplay();
    });

    window.addEventListener('resize', () => { setTimeout(refreshVisuals, 100); });
</script>
</body>
</html>